'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _lodash = require('lodash.merge');

var _lodash2 = _interopRequireDefault(_lodash);

var _reactJplayer = require('react-jplayer');

var _reactJplayer2 = _interopRequireDefault(_reactJplayer);

var _reactJplayerUtils = require('react-jplayer-utils');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _constants = require('../../util/constants');

var _getLoopState = require('../../util/getLoopState');

var _getLoopState2 = _interopRequireDefault(_getLoopState);

var _actions = require('../../actions/actions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var mapStateToProps = function mapStateToProps(_ref2, _ref) {
  var _extends2;

  var jPlayers = _ref2.jPlayers,
      jPlaylists = _ref2.jPlaylists;

  var id = _ref.id,
      children = _ref.children,
      customStates = _ref.customStates,
      keyBindings = _ref.keyBindings,
      attributes = _objectWithoutProperties(_ref, ['id', 'children', 'customStates', 'keyBindings']);

  var current = jPlaylists[id].current;
  var playlist = jPlaylists[id].playlist;
  var currentMediaId = void 0;

  if (playlist[current] !== undefined) {
    currentMediaId = playlist[current].id;
  }

  return {
    playNow: jPlaylists[id].playNow,
    shuffled: jPlaylists[id].shuffled,
    loop: jPlaylists[id].loop,
    shuffleOnLoop: jPlaylists[id].shuffleOnLoop,
    focused: jPlayers[id].focused,
    keyBindings: keyBindings,
    currentMediaId: currentMediaId,
    playlist: playlist,
    current: current,
    id: id,
    children: children,
    attributes: attributes,
    customStates: _extends((_extends2 = {}, _defineProperty(_extends2, _constants.classes.states.LOOPED_PLAYLIST, jPlaylists[id].loop === 'loop-playlist'), _defineProperty(_extends2, _constants.classes.states.SHUFFLED, jPlaylists[id].shuffled), _extends2), customStates)
  };
};

var mergeProps = function mergeProps(stateProps, _ref3) {
  var dispatch = _ref3.dispatch;
  return _extends({}, stateProps, {
    dispatch: dispatch,
    keyBindings: (0, _lodash2.default)({
      next: {
        key: 221, // ]
        fn: function fn() {
          return dispatch((0, _actions.next)(stateProps.id));
        }
      },
      previous: {
        key: 219, // [
        fn: function fn() {
          return dispatch((0, _actions.previous)(stateProps.id));
        }
      },
      shuffle: {
        key: 83, // s
        fn: function fn() {
          return dispatch((0, _actions.shuffle)(stateProps.id, undefined, true));
        }
      },
      loop: {
        key: 76, // l
        fn: function fn() {
          var loop = (0, _getLoopState2.default)(stateProps.loop);

          dispatch((0, _actions.setOption)(stateProps.id, 'loop', loop));
        }
      }
    }, stateProps.keyBindings)
  });
};

var JPlaylistContainer = function (_React$Component) {
  _inherits(JPlaylistContainer, _React$Component);

  function JPlaylistContainer() {
    var _ref4;

    var _temp, _this, _ret;

    _classCallCheck(this, JPlaylistContainer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref4 = JPlaylistContainer.__proto__ || Object.getPrototypeOf(JPlaylistContainer)).call.apply(_ref4, [this].concat(args))), _this), _this.setLoop = function () {
      if (_this.props.loop === 'loop') {
        _this.props.dispatch(_reactJplayer.actions.setOption(_this.props.id, 'loop', true));
      } else {
        _this.props.dispatch(_reactJplayer.actions.setOption(_this.props.id, 'loop', false));
      }
    }, _this.handlePlaylistLooped = function (prevProps) {
      if (_this.props.loop === 'loop-playlist') {
        // See if we need to shuffle before looping to start, and only shuffle if more than 1 item.
        if (_this.props.current === 0 && prevProps.current === prevProps.playlist.length - 1 && _this.props.shuffled && _this.props.shuffleOnLoop && _this.props.playlist.length > 1) {
          // Shuffle and play the media now
          _this.props.dispatch((0, _actions.shuffle)(_this.props.id, true, true));
        }
      }
    }, _this.playNext = function () {
      return _this.props.dispatch((0, _actions.next)(_this.props.id));
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(JPlaylistContainer, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.props.dispatch((0, _actions.setPlaylist)(this.props.id, this.props.playlist));
      this.props.dispatch(_reactJplayer.actions.setMedia(this.props.id, this.props.playlist[0]));
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.media = document.querySelector('#' + this.props.id + ' audio') || document.querySelector('#' + this.props.id + ' video');

      this.media.addEventListener('ended', this.playNext);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.playlist.length > 0 && this.props.currentMediaId !== nextProps.currentMediaId) {
        this.props.dispatch(_reactJplayer.actions.setMedia(nextProps.id, nextProps.playlist[nextProps.current]));
      } else if (nextProps.playlist.length === 0 && this.props.playlist.length > nextProps.playlist.length) {
        this.props.dispatch(_reactJplayer.actions.clearMedia(nextProps.id));
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.loop !== prevProps.loop) {
        this.setLoop();
      }

      if (this.props.playNow) {
        this.props.dispatch(_reactJplayer.actions.play(this.props.id));
        this.props.dispatch((0, _actions.setOption)(this.props.id, 'playNow', false));
      }

      if (this.props.currentMediaId !== prevProps.currentMediaId) {
        this.handlePlaylistLooped(prevProps);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.media.removeEventListener('ended', this.playNext);
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        _reactJplayer2.default,
        _extends({
          customStates: this.props.customStates, keyBindings: this.props.keyBindings
        }, this.props.attributes),
        this.props.children
      );
    }
  }], [{
    key: 'defaultProps',
    get: function get() {
      return {
        attributes: null,
        customStates: null,
        playNow: false,
        currentMediaId: null
      };
    }
  }, {
    key: 'propTypes',
    get: function get() {
      return {
        dispatch: _propTypes2.default.func.isRequired,
        id: _propTypes2.default.string.isRequired,
        attributes: _propTypes2.default.object,
        children: _propTypes2.default.node.isRequired,
        shuffled: _propTypes2.default.bool.isRequired,
        currentMediaId: _propTypes2.default.string,
        customStates: _propTypes2.default.object,
        playNow: _propTypes2.default.bool,
        loop: _propTypes2.default.string.isRequired,
        shuffleOnLoop: _propTypes2.default.bool.isRequired,
        current: _propTypes2.default.number.isRequired,
        playlist: _propTypes2.default.arrayOf(_propTypes2.default.shape({
          title: _propTypes2.default.string,
          artist: _propTypes2.default.string,
          mp3: _propTypes2.default.string,
          poster: _propTypes2.default.string,
          free: _propTypes2.default.bool
        })).isRequired,
        keyBindings: _propTypes2.default.object.isRequired
      };
    }
  }]);

  return JPlaylistContainer;
}(_react2.default.Component);

exports.default = (0, _reactJplayerUtils.connectWithId)(mapStateToProps, null, mergeProps)(JPlaylistContainer);