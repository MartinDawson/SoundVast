$.widget("custom.catcomplete", $.ui.autocomplete, {
    _create: function () {
        this._super();
        this.widget().menu("option", "items", "> :not(.ui-autocomplete-genre)");
    },
    _renderMenu: function (ul, items) {
        var that = this,
          currentGenre = "";
        $.each(items, function (index, item) {
            if (item.genre != currentGenre) {
                ul.append("<li class='ui-autocomplete-genre'>" + item.genre + "</li>");
                currentGenre = item.genre;
            }
            var li = that._renderItemData(ul, item);
            if (item.genre) {
                li.attr("aria-label", item.genre + " : " + item.label);
            }
        });
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJhdXRvY29tcGxldGUtY2F0ZWdvcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJC53aWRnZXQoXCJjdXN0b20uY2F0Y29tcGxldGVcIiwgJC51aS5hdXRvY29tcGxldGUsIHtcclxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9zdXBlcigpO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0KCkubWVudShcIm9wdGlvblwiLCBcIml0ZW1zXCIsIFwiPiA6bm90KC51aS1hdXRvY29tcGxldGUtZ2VucmUpXCIpO1xyXG4gICAgfSxcclxuICAgIF9yZW5kZXJNZW51OiBmdW5jdGlvbiAodWwsIGl0ZW1zKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgY3VycmVudEdlbnJlID0gXCJcIjtcclxuICAgICAgICAkLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5nZW5yZSAhPSBjdXJyZW50R2VucmUpIHtcclxuICAgICAgICAgICAgICAgIHVsLmFwcGVuZChcIjxsaSBjbGFzcz0ndWktYXV0b2NvbXBsZXRlLWdlbnJlJz5cIiArIGl0ZW0uZ2VucmUgKyBcIjwvbGk+XCIpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEdlbnJlID0gaXRlbS5nZW5yZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbGkgPSB0aGF0Ll9yZW5kZXJJdGVtRGF0YSh1bCwgaXRlbSk7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLmdlbnJlKSB7XHJcbiAgICAgICAgICAgICAgICBsaS5hdHRyKFwiYXJpYS1sYWJlbFwiLCBpdGVtLmdlbnJlICsgXCIgOiBcIiArIGl0ZW0ubGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0pOyJdLCJmaWxlIjoiYXV0b2NvbXBsZXRlLWNhdGVnb3J5LmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=


/*global jPlayerPlaylistExtended:true */
(function ($, undefined) {

    jPlayerPlaylistExtended = function (cssSelector, playlist, options) {
        var self = this;

        this.current = 0;
        this.shuffled = false;
        this.removing = false; // Flag is true during remove animation, disabling the remove() method until complete.

        this.cssSelector = $.extend({}, this._cssSelector, cssSelector); // Object: Containing the css selectors for jPlayer and its cssSelectorAncestor

        //Set the initial loop to the options loop
        this.loop = options.loop;

        this.options = $.extend(true, {
            keyBindings: {
                next: {
                    key: 221, // ]
                    fn: function () {
                        self.next();
                    }
                },
                previous: {
                    key: 219, // [
                    fn: function () {
                        self.previous();
                    }
                },
                shuffle: {
                    key: 83, // s
                    fn: function () {
                        self.shuffle();
                    }
                }
            },
            stateClass: {
                shuffled: "jp-state-shuffled"
            }
        }, this._options, options); // Object: The jPlayer constructor options for this playlist and the playlist options

        this.playlist = []; // Array of Objects: The current playlist displayed (Un-shuffled or Shuffled)
        this.original = []; // Array of Objects: The original playlist

        this._initPlaylist(playlist); // Copies playlist to this.original. Then mirrors this.original to this.playlist. Creating two arrays, where the element pointers match. (Enables pointer comparison.)

        // Setup the css selectors for the extra interface items used by the playlist.
        this.cssSelector.details = this.cssSelector.cssSelectorAncestor + " .jp-details"; // Note that jPlayer controls the text in the title element.
        this.cssSelector.playlist = this.cssSelector.cssPlaylistOptionsSelector + " .jp-playlist";
        this.cssSelector.next = this.cssSelector.cssSelectorAncestor + " .jp-next";
        this.cssSelector.previous = this.cssSelector.cssSelectorAncestor + " .jp-previous";
        this.cssSelector.shuffle = this.cssSelector.cssSelectorAncestor + " .jp-shuffle";
        this.cssSelector.shuffleOff = this.cssSelector.cssSelectorAncestor + " .jp-shuffle-off";

        // Override the cssSelectorAncestor given in options
        this.options.cssSelectorAncestor = this.cssSelector.cssSelectorAncestor;

        // Override the default repeat event handler
        this.options.repeat = function (event) {
            self.loop = event.jPlayer.options.loop;
        };
        
        // Create a ready event handler to initialize the playlist
        $(this.cssSelector.jPlayer).bind($.jPlayer.event.ready, function () {
            self._init();
        });

        //Create an ended event handler to move to the next item
        $(this.cssSelector.jPlayer).bind($.jPlayer.event.ended, function () {
            self.next();
        });

        // Create a play event handler to pause other instances
        $(this.cssSelector.jPlayer).bind($.jPlayer.event.play, function () {
            $(this).jPlayer("pauseOthers");
        });

        $(this.cssSelector.jPlayer).bind($.jPlayer.event.play, function () {
            $(this).jPlayer("pauseOthers");
        });

        // Create a resize event handler to show the title in full screen mode.
        $(this.cssSelector.jPlayer).bind($.jPlayer.event.resize, function (event) {
            if (event.jPlayer.options.fullScreen) {
                $(self.cssSelector.details).show();
            } else {
                $(self.cssSelector.details).hide();
            }
        });

        // Create click handlers for the extra buttons that do playlist functions.
        $(this.cssSelector.previous).click(function (e) {
            e.preventDefault();
            self.previous();
            self.blur(this);
        });

        $(this.cssSelector.next).click(function (e) {
            e.preventDefault();
            self.next(true);
            self.blur(this);
        });

        $(this.cssSelector.shuffle).click(function (e) {
            e.preventDefault();
            if (self.shuffled && $(self.cssSelector.jPlayer).jPlayer("option", "useStateClassSkin")) {
                self.shuffle(false);
            } else {
                self.shuffle(true);
            }
            self.blur(this);
        });
        $(this.cssSelector.shuffleOff).click(function (e) {
            e.preventDefault();
            self.shuffle(false);
            self.blur(this);
        }).hide();

        // Put the title in its initial display state
        if (!this.options.fullScreen) {
            $(this.cssSelector.details).hide();
        }

        // Remove the empty <li> from the page HTML. Allows page to be valid HTML, while not interfereing with display animations
        $(this.cssSelector.playlist + " ul").empty();

        // Create .on() handlers for the playlist items along with the free media and remove controls.
        this._createItemHandlers();

        // Instance jPlayer
        $(this.cssSelector.jPlayer).jPlayer(this.options);

        //Remove the looped class from the jPlayer as it's initialy incorrectly set in the original _updateButtons
        $(this.cssSelector.jPlayer).data().jPlayer.removeStateClass("looped");

        //Add a new stateClass for the extra loop option
        $.extend(true, this.options, {
            stateClass: {
                looped_playlist: "jp-state-looped-playlist"
            }
        });

        //Set the jPlayer options to extend these options
        $.extend(true, $(this.cssSelector.jPlayer).data().jPlayer.options, this.options);

        $(this.cssSelector.jPlayer).data().jPlayer.repeat = function () {
            var guiAction = typeof event === "object"; // Flags GUI click events so we know this was not a direct command, but an action taken by the user on the GUI.
            if (guiAction && this.options.useStateClassSkin && this.options.loop === "loop-playlist") {
                this._loop("off");
            } else if (guiAction && this.options.useStateClassSkin && this.options.loop === "off") {
                this._loop("loop");
                this.addStateClass("looped");
            }
            else {
                this.addStateClass("looped_playlist");
                this.removeStateClass("looped");
                this._loop("loop-playlist");
            }
        };

        $(this.cssSelector.jPlayer).data().jPlayer._updateButtons = function (playing) {
            if (playing === undefined) {
                playing = !this.status.paused;
            } else {
                this.status.paused = !playing;
            }
            // Apply the state classes. (For the useStateClassSkin:true option)
            if (playing) {
                this.addStateClass("playing");
            } else {
                this.removeStateClass("playing");
            }
            if (!this.status.noFullWindow && this.options.fullWindow) {
                this.addStateClass("fullScreen");
            } else {
                this.removeStateClass("fullScreen");
            }
            //Three types of loop states: Off, Loop, Loop-Playlist
            if (this.options.loop === "loop") {
                this.addStateClass("looped");
            }
            else if (this.options.loop === "loop-playlist") {
                this.addStateClass("looped_playlist");
                this.removeStateClass("looped");
            }
            else {
                this.removeStateClass("looped_playlist");
            }

            // Toggle the GUI element pairs. (For the useStateClassSkin:false option)
            if (this.css.jq.play.length && this.css.jq.pause.length) {
                if (playing) {
                    this.css.jq.play.hide();
                    this.css.jq.pause.show();
                } else {
                    this.css.jq.play.show();
                    this.css.jq.pause.hide();
                }
            }
            if (this.css.jq.restoreScreen.length && this.css.jq.fullScreen.length) {
                if (this.status.noFullWindow) {
                    this.css.jq.fullScreen.hide();
                    this.css.jq.restoreScreen.hide();
                } else if (this.options.fullWindow) {
                    this.css.jq.fullScreen.hide();
                    this.css.jq.restoreScreen.show();
                } else {
                    this.css.jq.fullScreen.show();
                    this.css.jq.restoreScreen.hide();
                }
            }
            if (this.css.jq.repeat.length && this.css.jq.repeatOff.length) {
                if (this.options.loop) {
                    this.css.jq.repeat.hide();
                    this.css.jq.repeatOff.show();
                } else {
                    this.css.jq.repeat.show();
                    this.css.jq.repeatOff.hide();
                }
            }
        }
    };

    jPlayerPlaylistExtended.prototype = {
        _cssSelector: {
            // static object, instanced in constructor
            jPlayer: "#jquery_jplayer_1",
            cssSelectorAncestor: "#jp_container_1"
        },
        _options: {
            // static object, instanced in constructor
            playlistOptions: {
                autoPlay: false,
                loopOnPrevious: false,
                shuffleOnLoop: true,
                enableRemoveControls: false,
                displayTime: "slow",
                addTime: "fast",
                removeTime: "fast",
                shuffleTime: "slow",
                itemClass: "jp-playlist-item",
                freeGroupClass: "jp-free-media",
                freeItemClass: "jp-playlist-item-free",
                removeItemClass: "jp-playlist-item-remove"
            }
        },
        option: function (option, value) { // For changing playlist options only
            if (value === undefined) {
                return this.options.playlistOptions[option];
            }

            this.options.playlistOptions[option] = value;

            switch (option) {
                case "enableRemoveControls":
                    this._updateControls();
                    break;
                case "itemClass":
                case "freeGroupClass":
                case "freeItemClass":
                case "removeItemClass":
                    this._refresh(true); // Instant
                    this._createItemHandlers();
                    break;
            }
            return this;
        },
        _init: function () {
            var self = this;
            this._refresh(function () {
                if (self.options.playlistOptions.autoPlay) {
                    self.play(self.current);
                } else {
                    self.select(self.current);
                }
            });
        },
        _initPlaylist: function (playlist) {
            this.current = 0;
            this.shuffled = false;
            this.removing = false;
            this.original = $.extend(true, [], playlist); // Copy the Array of Objects
            this._originalPlaylist();
        },
        _originalPlaylist: function () {
            var self = this;
            this.playlist = [];
            // Make both arrays point to the same object elements. Gives us 2 different arrays, each pointing to the same actual object. ie., Not copies of the object.
            $.each(this.original, function (i) {
                self.playlist[i] = self.original[i];
            });
        },
        _refresh: function (instant) {
            /* instant: Can be undefined, true or a function.
			 *	undefined -> use animation timings
			 *	true -> no animation
			 *	function -> use animation timings and excute function at half way point.
			 */
            var self = this;

            if (instant && !$.isFunction(instant)) {
                $(this.cssSelector.playlist + " ul").empty();
                $.each(this.playlist, function (i) {
                    $(self.cssSelector.playlist + " ul").append(self._createListItem(self.playlist[i]));
                });
                this._updateControls();
            } else {
                var displayTime = $(this.cssSelector.playlist + " ul").children().length ? this.options.playlistOptions.displayTime : 0;

                $(this.cssSelector.playlist + " ul").slideUp(displayTime, function () {
                    var $this = $(this);
                    $(this).empty();

                    $.each(self.playlist, function (i) {
                        $this.append(self._createListItem(self.playlist[i]));
                    });
                    self._updateControls();
                    if ($.isFunction(instant)) {
                        instant();
                    }
                    if (self.playlist.length) {
                        $(this).slideDown(self.options.playlistOptions.displayTime);
                    } else {
                        $(this).show();
                    }
                });
            }
        },
        _createListItem: function (media) {
            var self = this;

            // Wrap the <li> contents in a <div>
            var listItem = "<li><div>";

            // Create remove control
            listItem += "<a href='javascript:;' class='" + this.options.playlistOptions.removeItemClass + "'>&times;</a>";

            // Create links to free media
            if (media.free) {
                var first = true;
                listItem += "<span class='" + this.options.playlistOptions.freeGroupClass + "'>(";
                $.each(media, function (property, value) {
                    if ($.jPlayer.prototype.format[property]) { // Check property is a media format.
                        if (first) {
                            first = false;
                        } else {
                            listItem += " | ";
                        }
                        listItem += "<a class='" + self.options.playlistOptions.freeItemClass + "' href='" + value + "' tabindex='-1'>" + property + "</a>";
                    }
                });
                listItem += ")</span>";
            }

            // The title is given next in the HTML otherwise the float:right on the free media corrupts in IE6/7
            listItem += "<a href='javascript:;' class='" + this.options.playlistOptions.itemClass + "' tabindex='0'>" + "<img src='" + media.poster + "' />" + media.title + "</a>";
            listItem += (media.artist ? " <span class='jp-artist'>by " + media.artist + "</span>" : "");
            listItem += "</div></li>";

            return listItem;
        },
        _createItemHandlers: function () {
            var self = this;

            // Create live handlers for the playlist items
            $(this.cssSelector.playlist).off("click", "a." + this.options.playlistOptions.itemClass).on("click", "a." + this.options.playlistOptions.itemClass, function (e) {
                e.preventDefault();
                var index = $(this).parent().parent().index();
                if (self.current !== index) {
                    self.play(index);
                } else {
                    $(self.cssSelector.jPlayer).jPlayer("play");
                }
                self.blur(this);
            });

            // Create live handlers that disable free media links to force access via right click
            $(this.cssSelector.playlist).off("click", "a." + this.options.playlistOptions.freeItemClass).on("click", "a." + this.options.playlistOptions.freeItemClass, function (e) {
                e.preventDefault();
                $(this).parent().parent().find("." + self.options.playlistOptions.itemClass).click();
                self.blur(this);
            });

            // Create live handlers for the remove controls
            $(this.cssSelector.playlist).off("click", "a." + this.options.playlistOptions.removeItemClass).on("click", "a." + this.options.playlistOptions.removeItemClass, function (e) {
                e.preventDefault();
                var index = $(this).parent().parent().index();
                self.remove(index);
                self.blur(this);
            });
        },
        _updateControls: function () {
            if (this.options.playlistOptions.enableRemoveControls) {
                $(this.cssSelector.playlist + " ." + this.options.playlistOptions.removeItemClass).show();
            } else {
                $(this.cssSelector.playlist + " ." + this.options.playlistOptions.removeItemClass).hide();
            }

            if (this.shuffled) {
                $(this.cssSelector.jPlayer).jPlayer("addStateClass", "shuffled");
            } else {
                $(this.cssSelector.jPlayer).jPlayer("removeStateClass", "shuffled");
            }
            if ($(this.cssSelector.shuffle).length && $(this.cssSelector.shuffleOff).length) {
                if (this.shuffled) {
                    $(this.cssSelector.shuffleOff).show();
                    $(this.cssSelector.shuffle).hide();
                } else {
                    $(this.cssSelector.shuffleOff).hide();
                    $(this.cssSelector.shuffle).show();
                }
            }
        },
        _highlight: function (index) {
            if (this.playlist.length && index !== undefined) {
                $(this.cssSelector.playlist + " .jp-playlist-current").removeClass("jp-playlist-current");
                $(this.cssSelector.playlist + " li:nth-child(" + (index + 1) + ")").addClass("jp-playlist-current").find(".jp-playlist-item").addClass("jp-playlist-current");
                // $(this.cssSelector.details + " li").html("<span class='jp-title'>" + this.playlist[index].title + "</span>" + (this.playlist[index].artist ? " <span class='jp-artist'>by " + this.playlist[index].artist + "</span>" : ""));
            }
        },
        setPlaylist: function (playlist) {
            this._initPlaylist(playlist);
            this._init();
        },
        add: function (media, playNow) {
            $(this.cssSelector.playlist + " ul").append(this._createListItem(media)).find("li:last-child").hide().slideDown(this.options.playlistOptions.addTime);
            this._updateControls();
            this.original.push(media);
            this.playlist.push(media); // Both array elements share the same object pointer. Comforms with _initPlaylist(p) system.

            if (playNow) {
                this.play(this.playlist.length - 1);
            } else {
                if (this.original.length === 1) {
                    this.select(0);
                }
            }
        },
        remove: function (index) {
            var self = this;

            if (index === undefined) {
                this._initPlaylist([]);
                this._refresh(function () {
                    $(self.cssSelector.jPlayer).jPlayer("clearMedia");
                });
                return true;
            } else {

                if (this.removing) {
                    return false;
                } else {
                    index = (index < 0) ? self.original.length + index : index; // Negative index relates to end of array.
                    if (0 <= index && index < this.playlist.length) {
                        this.removing = true;

                        $(this.cssSelector.playlist + " li:nth-child(" + (index + 1) + ")").slideUp(this.options.playlistOptions.removeTime, function () {
                            $(this).remove();

                            if (self.shuffled) {
                                var item = self.playlist[index];
                                $.each(self.original, function (i) {
                                    if (self.original[i] === item) {
                                        self.original.splice(i, 1);
                                        return false; // Exit $.each
                                    }
                                });
                                self.playlist.splice(index, 1);
                            } else {
                                self.original.splice(index, 1);
                                self.playlist.splice(index, 1);
                            }

                            if (self.original.length) {
                                if (index === self.current) {
                                    self.current = (index < self.original.length) ? self.current : self.original.length - 1; // To cope when last element being selected when it was removed
                                    self.select(self.current);
                                } else if (index < self.current) {
                                    self.current--;
                                }
                            } else {
                                $(self.cssSelector.jPlayer).jPlayer("clearMedia");
                                self.current = 0;
                                self.shuffled = false;
                                self._updateControls();
                            }

                            self.removing = false;
                        });
                    }
                    return true;
                }
            }
        },
        select: function (index) {
            index = (index < 0) ? this.original.length + index : index; // Negative index relates to end of array.
            if (0 <= index && index < this.playlist.length) {
                this.current = index;
                this._highlight(index);
                $(this.cssSelector.jPlayer).jPlayer("setMedia", this.playlist[this.current]);
            } else {
                this.current = 0;
            }
        },
        play: function (index) {
            index = (index < 0) ? this.original.length + index : index; // Negative index relates to end of array.
            if (0 <= index && index < this.playlist.length) {
                if (this.playlist.length) {
                    this.select(index);
                    $(this.cssSelector.jPlayer).jPlayer("play");
                }
            } else if (index === undefined) {
                $(this.cssSelector.jPlayer).jPlayer("play");
            }
        },
        pause: function () {
            $(this.cssSelector.jPlayer).jPlayer("pause");
        },
        next: function (forcePlayNextTrack) {
            var index = (this.current + 1 < this.playlist.length) ? this.current + 1 : 0;

            if (this.loop === "loop" && !forcePlayNextTrack) {
                this.play(this.current);
            }
            else if (this.loop === "loop-playlist") {
                // See if we need to shuffle before looping to start, and only shuffle if more than 1 item.
                if (index === 0 && this.shuffled && this.options.playlistOptions.shuffleOnLoop && this.playlist.length > 1) {
                    this.shuffle(true, true); // playNow
                } else {
                    this.play(index);
                }
            }
            else {
                // The index will be zero if it just looped round
                if (index > 0) {
                    this.play(index);
                }
            }
        },
        previous: function () {
            var index = (this.current - 1 >= 0) ? this.current - 1 : this.playlist.length - 1;

            if (this.loop === "loop-playlist" && this.options.playlistOptions.loopOnPrevious || index < this.playlist.length - 1) {
                this.play(index);
            }
        },
        shuffle: function (shuffled, playNow) {
            var self = this;

            if (shuffled === undefined) {
                shuffled = !this.shuffled;
            }

            if (shuffled || shuffled !== this.shuffled) {

                $(this.cssSelector.playlist + " ul").slideUp(this.options.playlistOptions.shuffleTime, function () {
                    self.shuffled = shuffled;
                    if (shuffled) {
                        self.playlist.sort(function () {
                            return 0.5 - Math.random();
                        });
                    } else {
                        self._originalPlaylist();
                    }
                    self._refresh(true); // Instant

                    if (playNow || !$(self.cssSelector.jPlayer).data("jPlayer").status.paused) {
                        self.play(0);
                    } else {
                        self.select(0);
                    }

                    $(this).slideDown(self.options.playlistOptions.shuffleTime);
                });
            }
        },
        blur: function (that) {
            if ($(this.cssSelector.jPlayer).jPlayer("option", "autoBlur")) {
                $(that).blur();
            }
        }
    };
})(jQuery);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJqcGxheWVyLnBsYXlsaXN0LmV4dGVuZGVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypnbG9iYWwgalBsYXllclBsYXlsaXN0RXh0ZW5kZWQ6dHJ1ZSAqL1xuKGZ1bmN0aW9uICgkLCB1bmRlZmluZWQpIHtcblxuICAgIGpQbGF5ZXJQbGF5bGlzdEV4dGVuZGVkID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9yLCBwbGF5bGlzdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gMDtcbiAgICAgICAgdGhpcy5zaHVmZmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbW92aW5nID0gZmFsc2U7IC8vIEZsYWcgaXMgdHJ1ZSBkdXJpbmcgcmVtb3ZlIGFuaW1hdGlvbiwgZGlzYWJsaW5nIHRoZSByZW1vdmUoKSBtZXRob2QgdW50aWwgY29tcGxldGUuXG5cbiAgICAgICAgdGhpcy5jc3NTZWxlY3RvciA9ICQuZXh0ZW5kKHt9LCB0aGlzLl9jc3NTZWxlY3RvciwgY3NzU2VsZWN0b3IpOyAvLyBPYmplY3Q6IENvbnRhaW5pbmcgdGhlIGNzcyBzZWxlY3RvcnMgZm9yIGpQbGF5ZXIgYW5kIGl0cyBjc3NTZWxlY3RvckFuY2VzdG9yXG5cbiAgICAgICAgLy9TZXQgdGhlIGluaXRpYWwgbG9vcCB0byB0aGUgb3B0aW9ucyBsb29wXG4gICAgICAgIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcDtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7XG4gICAgICAgICAgICBrZXlCaW5kaW5nczoge1xuICAgICAgICAgICAgICAgIG5leHQ6IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAyMjEsIC8vIF1cbiAgICAgICAgICAgICAgICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmV2aW91czoge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IDIxOSwgLy8gW1xuICAgICAgICAgICAgICAgICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wcmV2aW91cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaHVmZmxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogODMsIC8vIHNcbiAgICAgICAgICAgICAgICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2h1ZmZsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXRlQ2xhc3M6IHtcbiAgICAgICAgICAgICAgICBzaHVmZmxlZDogXCJqcC1zdGF0ZS1zaHVmZmxlZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpOyAvLyBPYmplY3Q6IFRoZSBqUGxheWVyIGNvbnN0cnVjdG9yIG9wdGlvbnMgZm9yIHRoaXMgcGxheWxpc3QgYW5kIHRoZSBwbGF5bGlzdCBvcHRpb25zXG5cbiAgICAgICAgdGhpcy5wbGF5bGlzdCA9IFtdOyAvLyBBcnJheSBvZiBPYmplY3RzOiBUaGUgY3VycmVudCBwbGF5bGlzdCBkaXNwbGF5ZWQgKFVuLXNodWZmbGVkIG9yIFNodWZmbGVkKVxuICAgICAgICB0aGlzLm9yaWdpbmFsID0gW107IC8vIEFycmF5IG9mIE9iamVjdHM6IFRoZSBvcmlnaW5hbCBwbGF5bGlzdFxuXG4gICAgICAgIHRoaXMuX2luaXRQbGF5bGlzdChwbGF5bGlzdCk7IC8vIENvcGllcyBwbGF5bGlzdCB0byB0aGlzLm9yaWdpbmFsLiBUaGVuIG1pcnJvcnMgdGhpcy5vcmlnaW5hbCB0byB0aGlzLnBsYXlsaXN0LiBDcmVhdGluZyB0d28gYXJyYXlzLCB3aGVyZSB0aGUgZWxlbWVudCBwb2ludGVycyBtYXRjaC4gKEVuYWJsZXMgcG9pbnRlciBjb21wYXJpc29uLilcblxuICAgICAgICAvLyBTZXR1cCB0aGUgY3NzIHNlbGVjdG9ycyBmb3IgdGhlIGV4dHJhIGludGVyZmFjZSBpdGVtcyB1c2VkIGJ5IHRoZSBwbGF5bGlzdC5cbiAgICAgICAgdGhpcy5jc3NTZWxlY3Rvci5kZXRhaWxzID0gdGhpcy5jc3NTZWxlY3Rvci5jc3NTZWxlY3RvckFuY2VzdG9yICsgXCIgLmpwLWRldGFpbHNcIjsgLy8gTm90ZSB0aGF0IGpQbGF5ZXIgY29udHJvbHMgdGhlIHRleHQgaW4gdGhlIHRpdGxlIGVsZW1lbnQuXG4gICAgICAgIHRoaXMuY3NzU2VsZWN0b3IucGxheWxpc3QgPSB0aGlzLmNzc1NlbGVjdG9yLmNzc1BsYXlsaXN0T3B0aW9uc1NlbGVjdG9yICsgXCIgLmpwLXBsYXlsaXN0XCI7XG4gICAgICAgIHRoaXMuY3NzU2VsZWN0b3IubmV4dCA9IHRoaXMuY3NzU2VsZWN0b3IuY3NzU2VsZWN0b3JBbmNlc3RvciArIFwiIC5qcC1uZXh0XCI7XG4gICAgICAgIHRoaXMuY3NzU2VsZWN0b3IucHJldmlvdXMgPSB0aGlzLmNzc1NlbGVjdG9yLmNzc1NlbGVjdG9yQW5jZXN0b3IgKyBcIiAuanAtcHJldmlvdXNcIjtcbiAgICAgICAgdGhpcy5jc3NTZWxlY3Rvci5zaHVmZmxlID0gdGhpcy5jc3NTZWxlY3Rvci5jc3NTZWxlY3RvckFuY2VzdG9yICsgXCIgLmpwLXNodWZmbGVcIjtcbiAgICAgICAgdGhpcy5jc3NTZWxlY3Rvci5zaHVmZmxlT2ZmID0gdGhpcy5jc3NTZWxlY3Rvci5jc3NTZWxlY3RvckFuY2VzdG9yICsgXCIgLmpwLXNodWZmbGUtb2ZmXCI7XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGNzc1NlbGVjdG9yQW5jZXN0b3IgZ2l2ZW4gaW4gb3B0aW9uc1xuICAgICAgICB0aGlzLm9wdGlvbnMuY3NzU2VsZWN0b3JBbmNlc3RvciA9IHRoaXMuY3NzU2VsZWN0b3IuY3NzU2VsZWN0b3JBbmNlc3RvcjtcblxuICAgICAgICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCByZXBlYXQgZXZlbnQgaGFuZGxlclxuICAgICAgICB0aGlzLm9wdGlvbnMucmVwZWF0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLmxvb3AgPSBldmVudC5qUGxheWVyLm9wdGlvbnMubG9vcDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIHJlYWR5IGV2ZW50IGhhbmRsZXIgdG8gaW5pdGlhbGl6ZSB0aGUgcGxheWxpc3RcbiAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLmpQbGF5ZXIpLmJpbmQoJC5qUGxheWVyLmV2ZW50LnJlYWR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLl9pbml0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vQ3JlYXRlIGFuIGVuZGVkIGV2ZW50IGhhbmRsZXIgdG8gbW92ZSB0byB0aGUgbmV4dCBpdGVtXG4gICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5qUGxheWVyKS5iaW5kKCQualBsYXllci5ldmVudC5lbmRlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5uZXh0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHBsYXkgZXZlbnQgaGFuZGxlciB0byBwYXVzZSBvdGhlciBpbnN0YW5jZXNcbiAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLmpQbGF5ZXIpLmJpbmQoJC5qUGxheWVyLmV2ZW50LnBsYXksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQodGhpcykualBsYXllcihcInBhdXNlT3RoZXJzXCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3IualBsYXllcikuYmluZCgkLmpQbGF5ZXIuZXZlbnQucGxheSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5qUGxheWVyKFwicGF1c2VPdGhlcnNcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHJlc2l6ZSBldmVudCBoYW5kbGVyIHRvIHNob3cgdGhlIHRpdGxlIGluIGZ1bGwgc2NyZWVuIG1vZGUuXG4gICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5qUGxheWVyKS5iaW5kKCQualBsYXllci5ldmVudC5yZXNpemUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmpQbGF5ZXIub3B0aW9ucy5mdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgJChzZWxmLmNzc1NlbGVjdG9yLmRldGFpbHMpLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChzZWxmLmNzc1NlbGVjdG9yLmRldGFpbHMpLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGNsaWNrIGhhbmRsZXJzIGZvciB0aGUgZXh0cmEgYnV0dG9ucyB0aGF0IGRvIHBsYXlsaXN0IGZ1bmN0aW9ucy5cbiAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLnByZXZpb3VzKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc2VsZi5wcmV2aW91cygpO1xuICAgICAgICAgICAgc2VsZi5ibHVyKHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3IubmV4dCkuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNlbGYubmV4dCh0cnVlKTtcbiAgICAgICAgICAgIHNlbGYuYmx1cih0aGlzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLnNodWZmbGUpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5zaHVmZmxlZCAmJiAkKHNlbGYuY3NzU2VsZWN0b3IualBsYXllcikualBsYXllcihcIm9wdGlvblwiLCBcInVzZVN0YXRlQ2xhc3NTa2luXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zaHVmZmxlKGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zaHVmZmxlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5ibHVyKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLnNodWZmbGVPZmYpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZWxmLnNodWZmbGUoZmFsc2UpO1xuICAgICAgICAgICAgc2VsZi5ibHVyKHRoaXMpO1xuICAgICAgICB9KS5oaWRlKCk7XG5cbiAgICAgICAgLy8gUHV0IHRoZSB0aXRsZSBpbiBpdHMgaW5pdGlhbCBkaXNwbGF5IHN0YXRlXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5kZXRhaWxzKS5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGVtcHR5IDxsaT4gZnJvbSB0aGUgcGFnZSBIVE1MLiBBbGxvd3MgcGFnZSB0byBiZSB2YWxpZCBIVE1MLCB3aGlsZSBub3QgaW50ZXJmZXJlaW5nIHdpdGggZGlzcGxheSBhbmltYXRpb25zXG4gICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5wbGF5bGlzdCArIFwiIHVsXCIpLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIC5vbigpIGhhbmRsZXJzIGZvciB0aGUgcGxheWxpc3QgaXRlbXMgYWxvbmcgd2l0aCB0aGUgZnJlZSBtZWRpYSBhbmQgcmVtb3ZlIGNvbnRyb2xzLlxuICAgICAgICB0aGlzLl9jcmVhdGVJdGVtSGFuZGxlcnMoKTtcblxuICAgICAgICAvLyBJbnN0YW5jZSBqUGxheWVyXG4gICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5qUGxheWVyKS5qUGxheWVyKHRoaXMub3B0aW9ucyk7XG5cbiAgICAgICAgLy9SZW1vdmUgdGhlIGxvb3BlZCBjbGFzcyBmcm9tIHRoZSBqUGxheWVyIGFzIGl0J3MgaW5pdGlhbHkgaW5jb3JyZWN0bHkgc2V0IGluIHRoZSBvcmlnaW5hbCBfdXBkYXRlQnV0dG9uc1xuICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3IualBsYXllcikuZGF0YSgpLmpQbGF5ZXIucmVtb3ZlU3RhdGVDbGFzcyhcImxvb3BlZFwiKTtcblxuICAgICAgICAvL0FkZCBhIG5ldyBzdGF0ZUNsYXNzIGZvciB0aGUgZXh0cmEgbG9vcCBvcHRpb25cbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcy5vcHRpb25zLCB7XG4gICAgICAgICAgICBzdGF0ZUNsYXNzOiB7XG4gICAgICAgICAgICAgICAgbG9vcGVkX3BsYXlsaXN0OiBcImpwLXN0YXRlLWxvb3BlZC1wbGF5bGlzdFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vU2V0IHRoZSBqUGxheWVyIG9wdGlvbnMgdG8gZXh0ZW5kIHRoZXNlIG9wdGlvbnNcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgJCh0aGlzLmNzc1NlbGVjdG9yLmpQbGF5ZXIpLmRhdGEoKS5qUGxheWVyLm9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG5cbiAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLmpQbGF5ZXIpLmRhdGEoKS5qUGxheWVyLnJlcGVhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBndWlBY3Rpb24gPSB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCI7IC8vIEZsYWdzIEdVSSBjbGljayBldmVudHMgc28gd2Uga25vdyB0aGlzIHdhcyBub3QgYSBkaXJlY3QgY29tbWFuZCwgYnV0IGFuIGFjdGlvbiB0YWtlbiBieSB0aGUgdXNlciBvbiB0aGUgR1VJLlxuICAgICAgICAgICAgaWYgKGd1aUFjdGlvbiAmJiB0aGlzLm9wdGlvbnMudXNlU3RhdGVDbGFzc1NraW4gJiYgdGhpcy5vcHRpb25zLmxvb3AgPT09IFwibG9vcC1wbGF5bGlzdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9vcChcIm9mZlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3VpQWN0aW9uICYmIHRoaXMub3B0aW9ucy51c2VTdGF0ZUNsYXNzU2tpbiAmJiB0aGlzLm9wdGlvbnMubG9vcCA9PT0gXCJvZmZcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvb3AoXCJsb29wXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3RhdGVDbGFzcyhcImxvb3BlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3RhdGVDbGFzcyhcImxvb3BlZF9wbGF5bGlzdFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVN0YXRlQ2xhc3MoXCJsb29wZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9vcChcImxvb3AtcGxheWxpc3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLmpQbGF5ZXIpLmRhdGEoKS5qUGxheWVyLl91cGRhdGVCdXR0b25zID0gZnVuY3Rpb24gKHBsYXlpbmcpIHtcbiAgICAgICAgICAgIGlmIChwbGF5aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwbGF5aW5nID0gIXRoaXMuc3RhdHVzLnBhdXNlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMucGF1c2VkID0gIXBsYXlpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgc3RhdGUgY2xhc3Nlcy4gKEZvciB0aGUgdXNlU3RhdGVDbGFzc1NraW46dHJ1ZSBvcHRpb24pXG4gICAgICAgICAgICBpZiAocGxheWluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3RhdGVDbGFzcyhcInBsYXlpbmdcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU3RhdGVDbGFzcyhcInBsYXlpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdHVzLm5vRnVsbFdpbmRvdyAmJiB0aGlzLm9wdGlvbnMuZnVsbFdpbmRvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3RhdGVDbGFzcyhcImZ1bGxTY3JlZW5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU3RhdGVDbGFzcyhcImZ1bGxTY3JlZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1RocmVlIHR5cGVzIG9mIGxvb3Agc3RhdGVzOiBPZmYsIExvb3AsIExvb3AtUGxheWxpc3RcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9vcCA9PT0gXCJsb29wXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN0YXRlQ2xhc3MoXCJsb29wZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMubG9vcCA9PT0gXCJsb29wLXBsYXlsaXN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN0YXRlQ2xhc3MoXCJsb29wZWRfcGxheWxpc3RcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTdGF0ZUNsYXNzKFwibG9vcGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTdGF0ZUNsYXNzKFwibG9vcGVkX3BsYXlsaXN0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUb2dnbGUgdGhlIEdVSSBlbGVtZW50IHBhaXJzLiAoRm9yIHRoZSB1c2VTdGF0ZUNsYXNzU2tpbjpmYWxzZSBvcHRpb24pXG4gICAgICAgICAgICBpZiAodGhpcy5jc3MuanEucGxheS5sZW5ndGggJiYgdGhpcy5jc3MuanEucGF1c2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3MuanEucGxheS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3NzLmpxLnBhdXNlLnNob3coKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzcy5qcS5wbGF5LnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3MuanEucGF1c2UuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNzcy5qcS5yZXN0b3JlU2NyZWVuLmxlbmd0aCAmJiB0aGlzLmNzcy5qcS5mdWxsU2NyZWVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cy5ub0Z1bGxXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3MuanEuZnVsbFNjcmVlbi5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3NzLmpxLnJlc3RvcmVTY3JlZW4uaGlkZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZ1bGxXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3MuanEuZnVsbFNjcmVlbi5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3NzLmpxLnJlc3RvcmVTY3JlZW4uc2hvdygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3NzLmpxLmZ1bGxTY3JlZW4uc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzcy5qcS5yZXN0b3JlU2NyZWVuLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jc3MuanEucmVwZWF0Lmxlbmd0aCAmJiB0aGlzLmNzcy5qcS5yZXBlYXRPZmYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb29wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3NzLmpxLnJlcGVhdC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3NzLmpxLnJlcGVhdE9mZi5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3MuanEucmVwZWF0LnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3MuanEucmVwZWF0T2ZmLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalBsYXllclBsYXlsaXN0RXh0ZW5kZWQucHJvdG90eXBlID0ge1xuICAgICAgICBfY3NzU2VsZWN0b3I6IHtcbiAgICAgICAgICAgIC8vIHN0YXRpYyBvYmplY3QsIGluc3RhbmNlZCBpbiBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgalBsYXllcjogXCIjanF1ZXJ5X2pwbGF5ZXJfMVwiLFxuICAgICAgICAgICAgY3NzU2VsZWN0b3JBbmNlc3RvcjogXCIjanBfY29udGFpbmVyXzFcIlxuICAgICAgICB9LFxuICAgICAgICBfb3B0aW9uczoge1xuICAgICAgICAgICAgLy8gc3RhdGljIG9iamVjdCwgaW5zdGFuY2VkIGluIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBwbGF5bGlzdE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBhdXRvUGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9vcE9uUHJldmlvdXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNodWZmbGVPbkxvb3A6IHRydWUsXG4gICAgICAgICAgICAgICAgZW5hYmxlUmVtb3ZlQ29udHJvbHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlUaW1lOiBcInNsb3dcIixcbiAgICAgICAgICAgICAgICBhZGRUaW1lOiBcImZhc3RcIixcbiAgICAgICAgICAgICAgICByZW1vdmVUaW1lOiBcImZhc3RcIixcbiAgICAgICAgICAgICAgICBzaHVmZmxlVGltZTogXCJzbG93XCIsXG4gICAgICAgICAgICAgICAgaXRlbUNsYXNzOiBcImpwLXBsYXlsaXN0LWl0ZW1cIixcbiAgICAgICAgICAgICAgICBmcmVlR3JvdXBDbGFzczogXCJqcC1mcmVlLW1lZGlhXCIsXG4gICAgICAgICAgICAgICAgZnJlZUl0ZW1DbGFzczogXCJqcC1wbGF5bGlzdC1pdGVtLWZyZWVcIixcbiAgICAgICAgICAgICAgICByZW1vdmVJdGVtQ2xhc3M6IFwianAtcGxheWxpc3QtaXRlbS1yZW1vdmVcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcHRpb246IGZ1bmN0aW9uIChvcHRpb24sIHZhbHVlKSB7IC8vIEZvciBjaGFuZ2luZyBwbGF5bGlzdCBvcHRpb25zIG9ubHlcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wbGF5bGlzdE9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBsYXlsaXN0T3B0aW9uc1tvcHRpb25dID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuYWJsZVJlbW92ZUNvbnRyb2xzXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRyb2xzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpdGVtQ2xhc3NcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnJlZUdyb3VwQ2xhc3NcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnJlZUl0ZW1DbGFzc1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZW1vdmVJdGVtQ2xhc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaCh0cnVlKTsgLy8gSW5zdGFudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVJdGVtSGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX2luaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMucGxheWxpc3RPcHRpb25zLmF1dG9QbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxheShzZWxmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0KHNlbGYuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9pbml0UGxheWxpc3Q6IGZ1bmN0aW9uIChwbGF5bGlzdCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2h1ZmZsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWwgPSAkLmV4dGVuZCh0cnVlLCBbXSwgcGxheWxpc3QpOyAvLyBDb3B5IHRoZSBBcnJheSBvZiBPYmplY3RzXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFBsYXlsaXN0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9vcmlnaW5hbFBsYXlsaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnBsYXlsaXN0ID0gW107XG4gICAgICAgICAgICAvLyBNYWtlIGJvdGggYXJyYXlzIHBvaW50IHRvIHRoZSBzYW1lIG9iamVjdCBlbGVtZW50cy4gR2l2ZXMgdXMgMiBkaWZmZXJlbnQgYXJyYXlzLCBlYWNoIHBvaW50aW5nIHRvIHRoZSBzYW1lIGFjdHVhbCBvYmplY3QuIGllLiwgTm90IGNvcGllcyBvZiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgJC5lYWNoKHRoaXMub3JpZ2luYWwsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5bGlzdFtpXSA9IHNlbGYub3JpZ2luYWxbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgX3JlZnJlc2g6IGZ1bmN0aW9uIChpbnN0YW50KSB7XG4gICAgICAgICAgICAvKiBpbnN0YW50OiBDYW4gYmUgdW5kZWZpbmVkLCB0cnVlIG9yIGEgZnVuY3Rpb24uXG5cdFx0XHQgKlx0dW5kZWZpbmVkIC0+IHVzZSBhbmltYXRpb24gdGltaW5nc1xuXHRcdFx0ICpcdHRydWUgLT4gbm8gYW5pbWF0aW9uXG5cdFx0XHQgKlx0ZnVuY3Rpb24gLT4gdXNlIGFuaW1hdGlvbiB0aW1pbmdzIGFuZCBleGN1dGUgZnVuY3Rpb24gYXQgaGFsZiB3YXkgcG9pbnQuXG5cdFx0XHQgKi9cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKGluc3RhbnQgJiYgISQuaXNGdW5jdGlvbihpbnN0YW50KSkge1xuICAgICAgICAgICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5wbGF5bGlzdCArIFwiIHVsXCIpLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgJC5lYWNoKHRoaXMucGxheWxpc3QsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICQoc2VsZi5jc3NTZWxlY3Rvci5wbGF5bGlzdCArIFwiIHVsXCIpLmFwcGVuZChzZWxmLl9jcmVhdGVMaXN0SXRlbShzZWxmLnBsYXlsaXN0W2ldKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29udHJvbHMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlUaW1lID0gJCh0aGlzLmNzc1NlbGVjdG9yLnBsYXlsaXN0ICsgXCIgdWxcIikuY2hpbGRyZW4oKS5sZW5ndGggPyB0aGlzLm9wdGlvbnMucGxheWxpc3RPcHRpb25zLmRpc3BsYXlUaW1lIDogMDtcblxuICAgICAgICAgICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5wbGF5bGlzdCArIFwiIHVsXCIpLnNsaWRlVXAoZGlzcGxheVRpbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5lbXB0eSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICQuZWFjaChzZWxmLnBsYXlsaXN0LCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXBwZW5kKHNlbGYuX2NyZWF0ZUxpc3RJdGVtKHNlbGYucGxheWxpc3RbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUNvbnRyb2xzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oaW5zdGFudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5wbGF5bGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuc2xpZGVEb3duKHNlbGYub3B0aW9ucy5wbGF5bGlzdE9wdGlvbnMuZGlzcGxheVRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2NyZWF0ZUxpc3RJdGVtOiBmdW5jdGlvbiAobWVkaWEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgLy8gV3JhcCB0aGUgPGxpPiBjb250ZW50cyBpbiBhIDxkaXY+XG4gICAgICAgICAgICB2YXIgbGlzdEl0ZW0gPSBcIjxsaT48ZGl2PlwiO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgcmVtb3ZlIGNvbnRyb2xcbiAgICAgICAgICAgIGxpc3RJdGVtICs9IFwiPGEgaHJlZj0namF2YXNjcmlwdDo7JyBjbGFzcz0nXCIgKyB0aGlzLm9wdGlvbnMucGxheWxpc3RPcHRpb25zLnJlbW92ZUl0ZW1DbGFzcyArIFwiJz4mdGltZXM7PC9hPlwiO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgbGlua3MgdG8gZnJlZSBtZWRpYVxuICAgICAgICAgICAgaWYgKG1lZGlhLmZyZWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtICs9IFwiPHNwYW4gY2xhc3M9J1wiICsgdGhpcy5vcHRpb25zLnBsYXlsaXN0T3B0aW9ucy5mcmVlR3JvdXBDbGFzcyArIFwiJz4oXCI7XG4gICAgICAgICAgICAgICAgJC5lYWNoKG1lZGlhLCBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmpQbGF5ZXIucHJvdG90eXBlLmZvcm1hdFtwcm9wZXJ0eV0pIHsgLy8gQ2hlY2sgcHJvcGVydHkgaXMgYSBtZWRpYSBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0SXRlbSArPSBcIiB8IFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW0gKz0gXCI8YSBjbGFzcz0nXCIgKyBzZWxmLm9wdGlvbnMucGxheWxpc3RPcHRpb25zLmZyZWVJdGVtQ2xhc3MgKyBcIicgaHJlZj0nXCIgKyB2YWx1ZSArIFwiJyB0YWJpbmRleD0nLTEnPlwiICsgcHJvcGVydHkgKyBcIjwvYT5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtICs9IFwiKTwvc3Bhbj5cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIHRpdGxlIGlzIGdpdmVuIG5leHQgaW4gdGhlIEhUTUwgb3RoZXJ3aXNlIHRoZSBmbG9hdDpyaWdodCBvbiB0aGUgZnJlZSBtZWRpYSBjb3JydXB0cyBpbiBJRTYvN1xuICAgICAgICAgICAgbGlzdEl0ZW0gKz0gXCI8YSBocmVmPSdqYXZhc2NyaXB0OjsnIGNsYXNzPSdcIiArIHRoaXMub3B0aW9ucy5wbGF5bGlzdE9wdGlvbnMuaXRlbUNsYXNzICsgXCInIHRhYmluZGV4PScwJz5cIiArIFwiPGltZyBzcmM9J1wiICsgbWVkaWEucG9zdGVyICsgXCInIC8+XCIgKyBtZWRpYS50aXRsZSArIFwiPC9hPlwiO1xuICAgICAgICAgICAgbGlzdEl0ZW0gKz0gKG1lZGlhLmFydGlzdCA/IFwiIDxzcGFuIGNsYXNzPSdqcC1hcnRpc3QnPmJ5IFwiICsgbWVkaWEuYXJ0aXN0ICsgXCI8L3NwYW4+XCIgOiBcIlwiKTtcbiAgICAgICAgICAgIGxpc3RJdGVtICs9IFwiPC9kaXY+PC9saT5cIjtcblxuICAgICAgICAgICAgcmV0dXJuIGxpc3RJdGVtO1xuICAgICAgICB9LFxuICAgICAgICBfY3JlYXRlSXRlbUhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBsaXZlIGhhbmRsZXJzIGZvciB0aGUgcGxheWxpc3QgaXRlbXNcbiAgICAgICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5wbGF5bGlzdCkub2ZmKFwiY2xpY2tcIiwgXCJhLlwiICsgdGhpcy5vcHRpb25zLnBsYXlsaXN0T3B0aW9ucy5pdGVtQ2xhc3MpLm9uKFwiY2xpY2tcIiwgXCJhLlwiICsgdGhpcy5vcHRpb25zLnBsYXlsaXN0T3B0aW9ucy5pdGVtQ2xhc3MsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9ICQodGhpcykucGFyZW50KCkucGFyZW50KCkuaW5kZXgoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jdXJyZW50ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYXkoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQoc2VsZi5jc3NTZWxlY3Rvci5qUGxheWVyKS5qUGxheWVyKFwicGxheVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5ibHVyKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBsaXZlIGhhbmRsZXJzIHRoYXQgZGlzYWJsZSBmcmVlIG1lZGlhIGxpbmtzIHRvIGZvcmNlIGFjY2VzcyB2aWEgcmlnaHQgY2xpY2tcbiAgICAgICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5wbGF5bGlzdCkub2ZmKFwiY2xpY2tcIiwgXCJhLlwiICsgdGhpcy5vcHRpb25zLnBsYXlsaXN0T3B0aW9ucy5mcmVlSXRlbUNsYXNzKS5vbihcImNsaWNrXCIsIFwiYS5cIiArIHRoaXMub3B0aW9ucy5wbGF5bGlzdE9wdGlvbnMuZnJlZUl0ZW1DbGFzcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5wYXJlbnQoKS5maW5kKFwiLlwiICsgc2VsZi5vcHRpb25zLnBsYXlsaXN0T3B0aW9ucy5pdGVtQ2xhc3MpLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5ibHVyKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBsaXZlIGhhbmRsZXJzIGZvciB0aGUgcmVtb3ZlIGNvbnRyb2xzXG4gICAgICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3IucGxheWxpc3QpLm9mZihcImNsaWNrXCIsIFwiYS5cIiArIHRoaXMub3B0aW9ucy5wbGF5bGlzdE9wdGlvbnMucmVtb3ZlSXRlbUNsYXNzKS5vbihcImNsaWNrXCIsIFwiYS5cIiArIHRoaXMub3B0aW9ucy5wbGF5bGlzdE9wdGlvbnMucmVtb3ZlSXRlbUNsYXNzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAkKHRoaXMpLnBhcmVudCgpLnBhcmVudCgpLmluZGV4KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHNlbGYuYmx1cih0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBfdXBkYXRlQ29udHJvbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGxheWxpc3RPcHRpb25zLmVuYWJsZVJlbW92ZUNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLnBsYXlsaXN0ICsgXCIgLlwiICsgdGhpcy5vcHRpb25zLnBsYXlsaXN0T3B0aW9ucy5yZW1vdmVJdGVtQ2xhc3MpLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLnBsYXlsaXN0ICsgXCIgLlwiICsgdGhpcy5vcHRpb25zLnBsYXlsaXN0T3B0aW9ucy5yZW1vdmVJdGVtQ2xhc3MpLmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2h1ZmZsZWQpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3IualBsYXllcikualBsYXllcihcImFkZFN0YXRlQ2xhc3NcIiwgXCJzaHVmZmxlZFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLmpQbGF5ZXIpLmpQbGF5ZXIoXCJyZW1vdmVTdGF0ZUNsYXNzXCIsIFwic2h1ZmZsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJCh0aGlzLmNzc1NlbGVjdG9yLnNodWZmbGUpLmxlbmd0aCAmJiAkKHRoaXMuY3NzU2VsZWN0b3Iuc2h1ZmZsZU9mZikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2h1ZmZsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLnNodWZmbGVPZmYpLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLnNodWZmbGUpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3Iuc2h1ZmZsZU9mZikuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3Iuc2h1ZmZsZSkuc2hvdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2hpZ2hsaWdodDogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wbGF5bGlzdC5sZW5ndGggJiYgaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5wbGF5bGlzdCArIFwiIC5qcC1wbGF5bGlzdC1jdXJyZW50XCIpLnJlbW92ZUNsYXNzKFwianAtcGxheWxpc3QtY3VycmVudFwiKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3IucGxheWxpc3QgKyBcIiBsaTpudGgtY2hpbGQoXCIgKyAoaW5kZXggKyAxKSArIFwiKVwiKS5hZGRDbGFzcyhcImpwLXBsYXlsaXN0LWN1cnJlbnRcIikuZmluZChcIi5qcC1wbGF5bGlzdC1pdGVtXCIpLmFkZENsYXNzKFwianAtcGxheWxpc3QtY3VycmVudFwiKTtcbiAgICAgICAgICAgICAgICAvLyAkKHRoaXMuY3NzU2VsZWN0b3IuZGV0YWlscyArIFwiIGxpXCIpLmh0bWwoXCI8c3BhbiBjbGFzcz0nanAtdGl0bGUnPlwiICsgdGhpcy5wbGF5bGlzdFtpbmRleF0udGl0bGUgKyBcIjwvc3Bhbj5cIiArICh0aGlzLnBsYXlsaXN0W2luZGV4XS5hcnRpc3QgPyBcIiA8c3BhbiBjbGFzcz0nanAtYXJ0aXN0Jz5ieSBcIiArIHRoaXMucGxheWxpc3RbaW5kZXhdLmFydGlzdCArIFwiPC9zcGFuPlwiIDogXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRQbGF5bGlzdDogZnVuY3Rpb24gKHBsYXlsaXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0UGxheWxpc3QocGxheWxpc3QpO1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB9LFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChtZWRpYSwgcGxheU5vdykge1xuICAgICAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLnBsYXlsaXN0ICsgXCIgdWxcIikuYXBwZW5kKHRoaXMuX2NyZWF0ZUxpc3RJdGVtKG1lZGlhKSkuZmluZChcImxpOmxhc3QtY2hpbGRcIikuaGlkZSgpLnNsaWRlRG93bih0aGlzLm9wdGlvbnMucGxheWxpc3RPcHRpb25zLmFkZFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWwucHVzaChtZWRpYSk7XG4gICAgICAgICAgICB0aGlzLnBsYXlsaXN0LnB1c2gobWVkaWEpOyAvLyBCb3RoIGFycmF5IGVsZW1lbnRzIHNoYXJlIHRoZSBzYW1lIG9iamVjdCBwb2ludGVyLiBDb21mb3JtcyB3aXRoIF9pbml0UGxheWxpc3QocCkgc3lzdGVtLlxuXG4gICAgICAgICAgICBpZiAocGxheU5vdykge1xuICAgICAgICAgICAgICAgIHRoaXMucGxheSh0aGlzLnBsYXlsaXN0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRQbGF5bGlzdChbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICQoc2VsZi5jc3NTZWxlY3Rvci5qUGxheWVyKS5qUGxheWVyKFwiY2xlYXJNZWRpYVwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW1vdmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggPCAwKSA/IHNlbGYub3JpZ2luYWwubGVuZ3RoICsgaW5kZXggOiBpbmRleDsgLy8gTmVnYXRpdmUgaW5kZXggcmVsYXRlcyB0byBlbmQgb2YgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDw9IGluZGV4ICYmIGluZGV4IDwgdGhpcy5wbGF5bGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3IucGxheWxpc3QgKyBcIiBsaTpudGgtY2hpbGQoXCIgKyAoaW5kZXggKyAxKSArIFwiKVwiKS5zbGlkZVVwKHRoaXMub3B0aW9ucy5wbGF5bGlzdE9wdGlvbnMucmVtb3ZlVGltZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaHVmZmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHNlbGYucGxheWxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goc2VsZi5vcmlnaW5hbCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9yaWdpbmFsW2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vcmlnaW5hbC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBFeGl0ICQuZWFjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5bGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub3JpZ2luYWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5bGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9yaWdpbmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHNlbGYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50ID0gKGluZGV4IDwgc2VsZi5vcmlnaW5hbC5sZW5ndGgpID8gc2VsZi5jdXJyZW50IDogc2VsZi5vcmlnaW5hbC5sZW5ndGggLSAxOyAvLyBUbyBjb3BlIHdoZW4gbGFzdCBlbGVtZW50IGJlaW5nIHNlbGVjdGVkIHdoZW4gaXQgd2FzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0KHNlbGYuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCBzZWxmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChzZWxmLmNzc1NlbGVjdG9yLmpQbGF5ZXIpLmpQbGF5ZXIoXCJjbGVhck1lZGlhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNodWZmbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUNvbnRyb2xzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggPCAwKSA/IHRoaXMub3JpZ2luYWwubGVuZ3RoICsgaW5kZXggOiBpbmRleDsgLy8gTmVnYXRpdmUgaW5kZXggcmVsYXRlcyB0byBlbmQgb2YgYXJyYXkuXG4gICAgICAgICAgICBpZiAoMCA8PSBpbmRleCAmJiBpbmRleCA8IHRoaXMucGxheWxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3IualBsYXllcikualBsYXllcihcInNldE1lZGlhXCIsIHRoaXMucGxheWxpc3RbdGhpcy5jdXJyZW50XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBsYXk6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggPCAwKSA/IHRoaXMub3JpZ2luYWwubGVuZ3RoICsgaW5kZXggOiBpbmRleDsgLy8gTmVnYXRpdmUgaW5kZXggcmVsYXRlcyB0byBlbmQgb2YgYXJyYXkuXG4gICAgICAgICAgICBpZiAoMCA8PSBpbmRleCAmJiBpbmRleCA8IHRoaXMucGxheWxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGxheWxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmNzc1NlbGVjdG9yLmpQbGF5ZXIpLmpQbGF5ZXIoXCJwbGF5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5qUGxheWVyKS5qUGxheWVyKFwicGxheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQodGhpcy5jc3NTZWxlY3Rvci5qUGxheWVyKS5qUGxheWVyKFwicGF1c2VcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIChmb3JjZVBsYXlOZXh0VHJhY2spIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9ICh0aGlzLmN1cnJlbnQgKyAxIDwgdGhpcy5wbGF5bGlzdC5sZW5ndGgpID8gdGhpcy5jdXJyZW50ICsgMSA6IDA7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxvb3AgPT09IFwibG9vcFwiICYmICFmb3JjZVBsYXlOZXh0VHJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXkodGhpcy5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9vcCA9PT0gXCJsb29wLXBsYXlsaXN0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWUgaWYgd2UgbmVlZCB0byBzaHVmZmxlIGJlZm9yZSBsb29waW5nIHRvIHN0YXJ0LCBhbmQgb25seSBzaHVmZmxlIGlmIG1vcmUgdGhhbiAxIGl0ZW0uXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIHRoaXMuc2h1ZmZsZWQgJiYgdGhpcy5vcHRpb25zLnBsYXlsaXN0T3B0aW9ucy5zaHVmZmxlT25Mb29wICYmIHRoaXMucGxheWxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNodWZmbGUodHJ1ZSwgdHJ1ZSk7IC8vIHBsYXlOb3dcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXkoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBpbmRleCB3aWxsIGJlIHplcm8gaWYgaXQganVzdCBsb29wZWQgcm91bmRcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gKHRoaXMuY3VycmVudCAtIDEgPj0gMCkgPyB0aGlzLmN1cnJlbnQgLSAxIDogdGhpcy5wbGF5bGlzdC5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5sb29wID09PSBcImxvb3AtcGxheWxpc3RcIiAmJiB0aGlzLm9wdGlvbnMucGxheWxpc3RPcHRpb25zLmxvb3BPblByZXZpb3VzIHx8IGluZGV4IDwgdGhpcy5wbGF5bGlzdC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2h1ZmZsZTogZnVuY3Rpb24gKHNodWZmbGVkLCBwbGF5Tm93KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmIChzaHVmZmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2h1ZmZsZWQgPSAhdGhpcy5zaHVmZmxlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNodWZmbGVkIHx8IHNodWZmbGVkICE9PSB0aGlzLnNodWZmbGVkKSB7XG5cbiAgICAgICAgICAgICAgICAkKHRoaXMuY3NzU2VsZWN0b3IucGxheWxpc3QgKyBcIiB1bFwiKS5zbGlkZVVwKHRoaXMub3B0aW9ucy5wbGF5bGlzdE9wdGlvbnMuc2h1ZmZsZVRpbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zaHVmZmxlZCA9IHNodWZmbGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2h1ZmZsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGxheWxpc3Quc29ydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAtIE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29yaWdpbmFsUGxheWxpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZWZyZXNoKHRydWUpOyAvLyBJbnN0YW50XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXlOb3cgfHwgISQoc2VsZi5jc3NTZWxlY3Rvci5qUGxheWVyKS5kYXRhKFwialBsYXllclwiKS5zdGF0dXMucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYXkoMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuc2xpZGVEb3duKHNlbGYub3B0aW9ucy5wbGF5bGlzdE9wdGlvbnMuc2h1ZmZsZVRpbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBibHVyOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICAgICAgaWYgKCQodGhpcy5jc3NTZWxlY3Rvci5qUGxheWVyKS5qUGxheWVyKFwib3B0aW9uXCIsIFwiYXV0b0JsdXJcIikpIHtcbiAgICAgICAgICAgICAgICAkKHRoYXQpLmJsdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KShqUXVlcnkpOyJdLCJmaWxlIjoianBsYXllci5wbGF5bGlzdC5leHRlbmRlZC5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9

/**
 * History.js jQuery Adapter
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

// Closure
(function(window,undefined){
	"use strict";

	// Localise Globals
	var
		History = window.History = window.History||{},
		jQuery = window.jQuery;

	// Check Existence
	if ( typeof History.Adapter !== 'undefined' ) {
		throw new Error('History.js Adapter has already been loaded...');
	}

	// Add the Adapter
	History.Adapter = {
		/**
		 * History.Adapter.bind(el,event,callback)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {function} callback
		 * @return {void}
		 */
		bind: function(el,event,callback){
			jQuery(el).bind(event,callback);
		},

		/**
		 * History.Adapter.trigger(el,event)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {void}
		 */
		trigger: function(el,event,extra){
			jQuery(el).trigger(event,extra);
		},

		/**
		 * History.Adapter.extractEventData(key,event,extra)
		 * @param {string} key - key for the event data to extract
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {mixed}
		 */
		extractEventData: function(key,event,extra){
			// jQuery Native then jQuery Custom
			var result = (event && event.originalEvent && event.originalEvent[key]) || (extra && extra[key]) || undefined;

			// Return
			return result;
		},

		/**
		 * History.Adapter.onDomLoad(callback)
		 * @param {function} callback
		 * @return {void}
		 */
		onDomLoad: function(callback) {
			jQuery(callback);
		}
	};

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);

/**
 * History.js Core
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		console = window.console||undefined, // Prevent a JSLint complain
		document = window.document, // Make sure we are using the correct document
		navigator = window.navigator, // Make sure we are using the correct navigator
		sessionStorage = window.sessionStorage||false, // sessionStorage
		setTimeout = window.setTimeout,
		clearTimeout = window.clearTimeout,
		setInterval = window.setInterval,
		clearInterval = window.clearInterval,
		JSON = window.JSON,
		alert = window.alert,
		History = window.History = window.History||{}, // Public History Object
		history = window.history; // Old History Object

	try {
		sessionStorage.setItem('TEST', '1');
		sessionStorage.removeItem('TEST');
	} catch(e) {
		sessionStorage = false;
	}

	// MooTools Compatibility
	JSON.stringify = JSON.stringify||JSON.encode;
	JSON.parse = JSON.parse||JSON.decode;

	// Check Existence
	if ( typeof History.init !== 'undefined' ) {
		throw new Error('History.js Core has already been loaded...');
	}

	// Initialise History
	History.init = function(options){
		// Check Load Status of Adapter
		if ( typeof History.Adapter === 'undefined' ) {
			return false;
		}

		// Check Load Status of Core
		if ( typeof History.initCore !== 'undefined' ) {
			History.initCore();
		}

		// Check Load Status of HTML4 Support
		if ( typeof History.initHtml4 !== 'undefined' ) {
			History.initHtml4();
		}

		// Return true
		return true;
	};


	// ========================================================================
	// Initialise Core

	// Initialise Core
	History.initCore = function(options){
		// Initialise
		if ( typeof History.initCore.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initCore.initialized = true;
		}


		// ====================================================================
		// Options

		/**
		 * History.options
		 * Configurable options
		 */
		History.options = History.options||{};

		/**
		 * History.options.hashChangeInterval
		 * How long should the interval be before hashchange checks
		 */
		History.options.hashChangeInterval = History.options.hashChangeInterval || 100;

		/**
		 * History.options.safariPollInterval
		 * How long should the interval be before safari poll checks
		 */
		History.options.safariPollInterval = History.options.safariPollInterval || 500;

		/**
		 * History.options.doubleCheckInterval
		 * How long should the interval be before we perform a double check
		 */
		History.options.doubleCheckInterval = History.options.doubleCheckInterval || 500;

		/**
		 * History.options.disableSuid
		 * Force History not to append suid
		 */
		History.options.disableSuid = History.options.disableSuid || false;

		/**
		 * History.options.storeInterval
		 * How long should we wait between store calls
		 */
		History.options.storeInterval = History.options.storeInterval || 1000;

		/**
		 * History.options.busyDelay
		 * How long should we wait between busy events
		 */
		History.options.busyDelay = History.options.busyDelay || 250;

		/**
		 * History.options.debug
		 * If true will enable debug messages to be logged
		 */
		History.options.debug = History.options.debug || false;

		/**
		 * History.options.initialTitle
		 * What is the title of the initial state
		 */
		History.options.initialTitle = History.options.initialTitle || document.title;

		/**
		 * History.options.html4Mode
		 * If true, will force HTMl4 mode (hashtags)
		 */
		History.options.html4Mode = History.options.html4Mode || false;

		/**
		 * History.options.delayInit
		 * Want to override default options and call init manually.
		 */
		History.options.delayInit = History.options.delayInit || false;


		// ====================================================================
		// Interval record

		/**
		 * History.intervalList
		 * List of intervals set, to be cleared when document is unloaded.
		 */
		History.intervalList = [];

		/**
		 * History.clearAllIntervals
		 * Clears all setInterval instances.
		 */
		History.clearAllIntervals = function(){
			var i, il = History.intervalList;
			if (typeof il !== "undefined" && il !== null) {
				for (i = 0; i < il.length; i++) {
					clearInterval(il[i]);
				}
				History.intervalList = null;
			}
		};


		// ====================================================================
		// Debug

		/**
		 * History.debug(message,...)
		 * Logs the passed arguments if debug enabled
		 */
		History.debug = function(){
			if ( (History.options.debug||false) ) {
				History.log.apply(History,arguments);
			}
		};

		/**
		 * History.log(message,...)
		 * Logs the passed arguments
		 */
		History.log = function(){
			// Prepare
			var
				consoleExists = !(typeof console === 'undefined' || typeof console.log === 'undefined' || typeof console.log.apply === 'undefined'),
				textarea = document.getElementById('log'),
				message,
				i,n,
				args,arg
				;

			// Write to Console
			if ( consoleExists ) {
				args = Array.prototype.slice.call(arguments);
				message = args.shift();
				if ( typeof console.debug !== 'undefined' ) {
					console.debug.apply(console,[message,args]);
				}
				else {
					console.log.apply(console,[message,args]);
				}
			}
			else {
				message = ("\n"+arguments[0]+"\n");
			}

			// Write to log
			for ( i=1,n=arguments.length; i<n; ++i ) {
				arg = arguments[i];
				if ( typeof arg === 'object' && typeof JSON !== 'undefined' ) {
					try {
						arg = JSON.stringify(arg);
					}
					catch ( Exception ) {
						// Recursive Object
					}
				}
				message += "\n"+arg+"\n";
			}

			// Textarea
			if ( textarea ) {
				textarea.value += message+"\n-----\n";
				textarea.scrollTop = textarea.scrollHeight - textarea.clientHeight;
			}
			// No Textarea, No Console
			else if ( !consoleExists ) {
				alert(message);
			}

			// Return true
			return true;
		};


		// ====================================================================
		// Emulated Status

		/**
		 * History.getInternetExplorerMajorVersion()
		 * Get's the major version of Internet Explorer
		 * @return {integer}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 * @author James Padolsey <https://gist.github.com/527683>
		 */
		History.getInternetExplorerMajorVersion = function(){
			var result = History.getInternetExplorerMajorVersion.cached =
					(typeof History.getInternetExplorerMajorVersion.cached !== 'undefined')
				?	History.getInternetExplorerMajorVersion.cached
				:	(function(){
						var v = 3,
								div = document.createElement('div'),
								all = div.getElementsByTagName('i');
						while ( (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->') && all[0] ) {}
						return (v > 4) ? v : false;
					})()
				;
			return result;
		};

		/**
		 * History.isInternetExplorer()
		 * Are we using Internet Explorer?
		 * @return {boolean}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 */
		History.isInternetExplorer = function(){
			var result =
				History.isInternetExplorer.cached =
				(typeof History.isInternetExplorer.cached !== 'undefined')
					?	History.isInternetExplorer.cached
					:	Boolean(History.getInternetExplorerMajorVersion())
				;
			return result;
		};

		/**
		 * History.emulated
		 * Which features require emulating?
		 */

		if (History.options.html4Mode) {
			History.emulated = {
				pushState : true,
				hashChange: true
			};
		}

		else {

			History.emulated = {
				pushState: !Boolean(
					window.history && window.history.pushState && window.history.replaceState
					&& !(
						(/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i).test(navigator.userAgent) /* disable for versions of iOS before version 4.3 (8F190) */
						|| (/AppleWebKit\/5([0-2]|3[0-2])/i).test(navigator.userAgent) /* disable for the mercury iOS browser, or at least older versions of the webkit engine */
					)
				),
				hashChange: Boolean(
					!(('onhashchange' in window) || ('onhashchange' in document))
					||
					(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8)
				)
			};
		}

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = !History.emulated.pushState;

		/**
		 * History.bugs
		 * Which bugs are present
		 */
		History.bugs = {
			/**
			 * Safari 5 and Safari iOS 4 fail to return to the correct state once a hash is replaced by a `replaceState` call
			 * https://bugs.webkit.org/show_bug.cgi?id=56249
			 */
			setHash: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * Safari 5 and Safari iOS 4 sometimes fail to apply the state change under busy conditions
			 * https://bugs.webkit.org/show_bug.cgi?id=42940
			 */
			safariPoll: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * MSIE 6 and 7 sometimes do not apply a hash even it was told to (requiring a second call to the apply function)
			 */
			ieDoubleCheck: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8),

			/**
			 * MSIE 6 requires the entire hash to be encoded for the hashes to trigger the onHashChange event
			 */
			hashEscape: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 7)
		};

		/**
		 * History.isEmptyObject(obj)
		 * Checks to see if the Object is Empty
		 * @param {Object} obj
		 * @return {boolean}
		 */
		History.isEmptyObject = function(obj) {
			for ( var name in obj ) {
				if ( obj.hasOwnProperty(name) ) {
					return false;
				}
			}
			return true;
		};

		/**
		 * History.cloneObject(obj)
		 * Clones a object and eliminate all references to the original contexts
		 * @param {Object} obj
		 * @return {Object}
		 */
		History.cloneObject = function(obj) {
			var hash,newObj;
			if ( obj ) {
				hash = JSON.stringify(obj);
				newObj = JSON.parse(hash);
			}
			else {
				newObj = {};
			}
			return newObj;
		};


		// ====================================================================
		// URL Helpers

		/**
		 * History.getRootUrl()
		 * Turns "http://mysite.com/dir/page.html?asd" into "http://mysite.com"
		 * @return {String} rootUrl
		 */
		History.getRootUrl = function(){
			// Create
			var rootUrl = document.location.protocol+'//'+(document.location.hostname||document.location.host);
			if ( document.location.port||false ) {
				rootUrl += ':'+document.location.port;
			}
			rootUrl += '/';

			// Return
			return rootUrl;
		};

		/**
		 * History.getBaseHref()
		 * Fetches the `href` attribute of the `<base href="...">` element if it exists
		 * @return {String} baseHref
		 */
		History.getBaseHref = function(){
			// Create
			var
				baseElements = document.getElementsByTagName('base'),
				baseElement = null,
				baseHref = '';

			// Test for Base Element
			if ( baseElements.length === 1 ) {
				// Prepare for Base Element
				baseElement = baseElements[0];
				baseHref = baseElement.href.replace(/[^\/]+$/,'');
			}

			// Adjust trailing slash
			baseHref = baseHref.replace(/\/+$/,'');
			if ( baseHref ) baseHref += '/';

			// Return
			return baseHref;
		};

		/**
		 * History.getBaseUrl()
		 * Fetches the baseHref or basePageUrl or rootUrl (whichever one exists first)
		 * @return {String} baseUrl
		 */
		History.getBaseUrl = function(){
			// Create
			var baseUrl = History.getBaseHref()||History.getBasePageUrl()||History.getRootUrl();

			// Return
			return baseUrl;
		};

		/**
		 * History.getPageUrl()
		 * Fetches the URL of the current page
		 * @return {String} pageUrl
		 */
		History.getPageUrl = function(){
			// Fetch
			var
				State = History.getState(false,false),
				stateUrl = (State||{}).url||History.getLocationHref(),
				pageUrl;

			// Create
			pageUrl = stateUrl.replace(/\/+$/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/\./).test(part) ? part : part+'/';
			});

			// Return
			return pageUrl;
		};

		/**
		 * History.getBasePageUrl()
		 * Fetches the Url of the directory of the current page
		 * @return {String} basePageUrl
		 */
		History.getBasePageUrl = function(){
			// Create
			var basePageUrl = (History.getLocationHref()).replace(/[#\?].*/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/[^\/]$/).test(part) ? '' : part;
			}).replace(/\/+$/,'')+'/';

			// Return
			return basePageUrl;
		};

		/**
		 * History.getFullUrl(url)
		 * Ensures that we have an absolute URL and not a relative URL
		 * @param {string} url
		 * @param {Boolean} allowBaseHref
		 * @return {string} fullUrl
		 */
		History.getFullUrl = function(url,allowBaseHref){
			// Prepare
			var fullUrl = url, firstChar = url.substring(0,1);
			allowBaseHref = (typeof allowBaseHref === 'undefined') ? true : allowBaseHref;

			// Check
			if ( /[a-z]+\:\/\//.test(url) ) {
				// Full URL
			}
			else if ( firstChar === '/' ) {
				// Root URL
				fullUrl = History.getRootUrl()+url.replace(/^\/+/,'');
			}
			else if ( firstChar === '#' ) {
				// Anchor URL
				fullUrl = History.getPageUrl().replace(/#.*/,'')+url;
			}
			else if ( firstChar === '?' ) {
				// Query URL
				fullUrl = History.getPageUrl().replace(/[\?#].*/,'')+url;
			}
			else {
				// Relative URL
				if ( allowBaseHref ) {
					fullUrl = History.getBaseUrl()+url.replace(/^(\.\/)+/,'');
				} else {
					fullUrl = History.getBasePageUrl()+url.replace(/^(\.\/)+/,'');
				}
				// We have an if condition above as we do not want hashes
				// which are relative to the baseHref in our URLs
				// as if the baseHref changes, then all our bookmarks
				// would now point to different locations
				// whereas the basePageUrl will always stay the same
			}

			// Return
			return fullUrl.replace(/\#$/,'');
		};

		/**
		 * History.getShortUrl(url)
		 * Ensures that we have a relative URL and not a absolute URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getShortUrl = function(url){
			// Prepare
			var shortUrl = url, baseUrl = History.getBaseUrl(), rootUrl = History.getRootUrl();

			// Trim baseUrl
			if ( History.emulated.pushState ) {
				// We are in a if statement as when pushState is not emulated
				// The actual url these short urls are relative to can change
				// So within the same session, we the url may end up somewhere different
				shortUrl = shortUrl.replace(baseUrl,'');
			}

			// Trim rootUrl
			shortUrl = shortUrl.replace(rootUrl,'/');

			// Ensure we can still detect it as a state
			if ( History.isTraditionalAnchor(shortUrl) ) {
				shortUrl = './'+shortUrl;
			}

			// Clean It
			shortUrl = shortUrl.replace(/^(\.\/)+/g,'./').replace(/\#$/,'');

			// Return
			return shortUrl;
		};

		/**
		 * History.getLocationHref(document)
		 * Returns a normalized version of document.location.href
		 * accounting for browser inconsistencies, etc.
		 *
		 * This URL will be URI-encoded and will include the hash
		 *
		 * @param {object} document
		 * @return {string} url
		 */
		History.getLocationHref = function(doc) {
			doc = doc || document;

			// most of the time, this will be true
			if (doc.URL === doc.location.href)
				return doc.location.href;

			// some versions of webkit URI-decode document.location.href
			// but they leave document.URL in an encoded state
			if (doc.location.href === decodeURIComponent(doc.URL))
				return doc.URL;

			// FF 3.6 only updates document.URL when a page is reloaded
			// document.location.href is updated correctly
			if (doc.location.hash && decodeURIComponent(doc.location.href.replace(/^[^#]+/, "")) === doc.location.hash)
				return doc.location.href;

			if (doc.URL.indexOf('#') == -1 && doc.location.href.indexOf('#') != -1)
				return doc.location.href;
			
			return doc.URL || doc.location.href;
		};


		// ====================================================================
		// State Storage

		/**
		 * History.store
		 * The store for all session specific data
		 */
		History.store = {};

		/**
		 * History.idToState
		 * 1-1: State ID to State Object
		 */
		History.idToState = History.idToState||{};

		/**
		 * History.stateToId
		 * 1-1: State String to State ID
		 */
		History.stateToId = History.stateToId||{};

		/**
		 * History.urlToId
		 * 1-1: State URL to State ID
		 */
		History.urlToId = History.urlToId||{};

		/**
		 * History.storedStates
		 * Store the states in an array
		 */
		History.storedStates = History.storedStates||[];

		/**
		 * History.savedStates
		 * Saved the states in an array
		 */
		History.savedStates = History.savedStates||[];

		/**
		 * History.noramlizeStore()
		 * Noramlize the store by adding necessary values
		 */
		History.normalizeStore = function(){
			History.store.idToState = History.store.idToState||{};
			History.store.urlToId = History.store.urlToId||{};
			History.store.stateToId = History.store.stateToId||{};
		};

		/**
		 * History.getState()
		 * Get an object containing the data, title and url of the current state
		 * @param {Boolean} friendly
		 * @param {Boolean} create
		 * @return {Object} State
		 */
		History.getState = function(friendly,create){
			// Prepare
			if ( typeof friendly === 'undefined' ) { friendly = true; }
			if ( typeof create === 'undefined' ) { create = true; }

			// Fetch
			var State = History.getLastSavedState();

			// Create
			if ( !State && create ) {
				State = History.createStateObject();
			}

			// Adjust
			if ( friendly ) {
				State = History.cloneObject(State);
				State.url = State.cleanUrl||State.url;
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByState(State)
		 * Gets a ID for a State
		 * @param {State} newState
		 * @return {String} id
		 */
		History.getIdByState = function(newState){

			// Fetch ID
			var id = History.extractId(newState.url),
				str;

			if ( !id ) {
				// Find ID via State String
				str = History.getStateString(newState);
				if ( typeof History.stateToId[str] !== 'undefined' ) {
					id = History.stateToId[str];
				}
				else if ( typeof History.store.stateToId[str] !== 'undefined' ) {
					id = History.store.stateToId[str];
				}
				else {
					// Generate a new ID
					while ( true ) {
						id = (new Date()).getTime() + String(Math.random()).replace(/\D/g,'');
						if ( typeof History.idToState[id] === 'undefined' && typeof History.store.idToState[id] === 'undefined' ) {
							break;
						}
					}

					// Apply the new State to the ID
					History.stateToId[str] = id;
					History.idToState[id] = newState;
				}
			}

			// Return ID
			return id;
		};

		/**
		 * History.normalizeState(State)
		 * Expands a State Object
		 * @param {object} State
		 * @return {object}
		 */
		History.normalizeState = function(oldState){
			// Variables
			var newState, dataNotEmpty;

			// Prepare
			if ( !oldState || (typeof oldState !== 'object') ) {
				oldState = {};
			}

			// Check
			if ( typeof oldState.normalized !== 'undefined' ) {
				return oldState;
			}

			// Adjust
			if ( !oldState.data || (typeof oldState.data !== 'object') ) {
				oldState.data = {};
			}

			// ----------------------------------------------------------------

			// Create
			newState = {};
			newState.normalized = true;
			newState.title = oldState.title||'';
			newState.url = History.getFullUrl(oldState.url?oldState.url:(History.getLocationHref()));
			newState.hash = History.getShortUrl(newState.url);
			newState.data = History.cloneObject(oldState.data);

			// Fetch ID
			newState.id = History.getIdByState(newState);

			// ----------------------------------------------------------------

			// Clean the URL
			newState.cleanUrl = newState.url.replace(/\??\&_suid.*/,'');
			newState.url = newState.cleanUrl;

			// Check to see if we have more than just a url
			dataNotEmpty = !History.isEmptyObject(newState.data);

			// Apply
			if ( (newState.title || dataNotEmpty) && History.options.disableSuid !== true ) {
				// Add ID to Hash
				newState.hash = History.getShortUrl(newState.url).replace(/\??\&_suid.*/,'');
				if ( !/\?/.test(newState.hash) ) {
					newState.hash += '?';
				}
				newState.hash += '&_suid='+newState.id;
			}

			// Create the Hashed URL
			newState.hashedUrl = History.getFullUrl(newState.hash);

			// ----------------------------------------------------------------

			// Update the URL if we have a duplicate
			if ( (History.emulated.pushState || History.bugs.safariPoll) && History.hasUrlDuplicate(newState) ) {
				newState.url = newState.hashedUrl;
			}

			// ----------------------------------------------------------------

			// Return
			return newState;
		};

		/**
		 * History.createStateObject(data,title,url)
		 * Creates a object based on the data, title and url state params
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {object}
		 */
		History.createStateObject = function(data,title,url){
			// Hashify
			var State = {
				'data': data,
				'title': title,
				'url': url
			};

			// Expand the State
			State = History.normalizeState(State);

			// Return object
			return State;
		};

		/**
		 * History.getStateById(id)
		 * Get a state by it's UID
		 * @param {String} id
		 */
		History.getStateById = function(id){
			// Prepare
			id = String(id);

			// Retrieve
			var State = History.idToState[id] || History.store.idToState[id] || undefined;

			// Return State
			return State;
		};

		/**
		 * Get a State's String
		 * @param {State} passedState
		 */
		History.getStateString = function(passedState){
			// Prepare
			var State, cleanedState, str;

			// Fetch
			State = History.normalizeState(passedState);

			// Clean
			cleanedState = {
				data: State.data,
				title: passedState.title,
				url: passedState.url
			};

			// Fetch
			str = JSON.stringify(cleanedState);

			// Return
			return str;
		};

		/**
		 * Get a State's ID
		 * @param {State} passedState
		 * @return {String} id
		 */
		History.getStateId = function(passedState){
			// Prepare
			var State, id;

			// Fetch
			State = History.normalizeState(passedState);

			// Fetch
			id = State.id;

			// Return
			return id;
		};

		/**
		 * History.getHashByState(State)
		 * Creates a Hash for the State Object
		 * @param {State} passedState
		 * @return {String} hash
		 */
		History.getHashByState = function(passedState){
			// Prepare
			var State, hash;

			// Fetch
			State = History.normalizeState(passedState);

			// Hash
			hash = State.hash;

			// Return
			return hash;
		};

		/**
		 * History.extractId(url_or_hash)
		 * Get a State ID by it's URL or Hash
		 * @param {string} url_or_hash
		 * @return {string} id
		 */
		History.extractId = function ( url_or_hash ) {
			// Prepare
			var id,parts,url, tmp;

			// Extract
			
			// If the URL has a #, use the id from before the #
			if (url_or_hash.indexOf('#') != -1)
			{
				tmp = url_or_hash.split("#")[0];
			}
			else
			{
				tmp = url_or_hash;
			}
			
			parts = /(.*)\&_suid=([0-9]+)$/.exec(tmp);
			url = parts ? (parts[1]||url_or_hash) : url_or_hash;
			id = parts ? String(parts[2]||'') : '';

			// Return
			return id||false;
		};

		/**
		 * History.isTraditionalAnchor
		 * Checks to see if the url is a traditional anchor or not
		 * @param {String} url_or_hash
		 * @return {Boolean}
		 */
		History.isTraditionalAnchor = function(url_or_hash){
			// Check
			var isTraditional = !(/[\/\?\.]/.test(url_or_hash));

			// Return
			return isTraditional;
		};

		/**
		 * History.extractState
		 * Get a State by it's URL or Hash
		 * @param {String} url_or_hash
		 * @return {State|null}
		 */
		History.extractState = function(url_or_hash,create){
			// Prepare
			var State = null, id, url;
			create = create||false;

			// Fetch SUID
			id = History.extractId(url_or_hash);
			if ( id ) {
				State = History.getStateById(id);
			}

			// Fetch SUID returned no State
			if ( !State ) {
				// Fetch URL
				url = History.getFullUrl(url_or_hash);

				// Check URL
				id = History.getIdByUrl(url)||false;
				if ( id ) {
					State = History.getStateById(id);
				}

				// Create State
				if ( !State && create && !History.isTraditionalAnchor(url_or_hash) ) {
					State = History.createStateObject(null,null,url);
				}
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByUrl()
		 * Get a State ID by a State URL
		 */
		History.getIdByUrl = function(url){
			// Fetch
			var id = History.urlToId[url] || History.store.urlToId[url] || undefined;

			// Return
			return id;
		};

		/**
		 * History.getLastSavedState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastSavedState = function(){
			return History.savedStates[History.savedStates.length-1]||undefined;
		};

		/**
		 * History.getLastStoredState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastStoredState = function(){
			return History.storedStates[History.storedStates.length-1]||undefined;
		};

		/**
		 * History.hasUrlDuplicate
		 * Checks if a Url will have a url conflict
		 * @param {Object} newState
		 * @return {Boolean} hasDuplicate
		 */
		History.hasUrlDuplicate = function(newState) {
			// Prepare
			var hasDuplicate = false,
				oldState;

			// Fetch
			oldState = History.extractState(newState.url);

			// Check
			hasDuplicate = oldState && oldState.id !== newState.id;

			// Return
			return hasDuplicate;
		};

		/**
		 * History.storeState
		 * Store a State
		 * @param {Object} newState
		 * @return {Object} newState
		 */
		History.storeState = function(newState){
			// Store the State
			History.urlToId[newState.url] = newState.id;

			// Push the State
			History.storedStates.push(History.cloneObject(newState));

			// Return newState
			return newState;
		};

		/**
		 * History.isLastSavedState(newState)
		 * Tests to see if the state is the last state
		 * @param {Object} newState
		 * @return {boolean} isLast
		 */
		History.isLastSavedState = function(newState){
			// Prepare
			var isLast = false,
				newId, oldState, oldId;

			// Check
			if ( History.savedStates.length ) {
				newId = newState.id;
				oldState = History.getLastSavedState();
				oldId = oldState.id;

				// Check
				isLast = (newId === oldId);
			}

			// Return
			return isLast;
		};

		/**
		 * History.saveState
		 * Push a State
		 * @param {Object} newState
		 * @return {boolean} changed
		 */
		History.saveState = function(newState){
			// Check Hash
			if ( History.isLastSavedState(newState) ) {
				return false;
			}

			// Push the State
			History.savedStates.push(History.cloneObject(newState));

			// Return true
			return true;
		};

		/**
		 * History.getStateByIndex()
		 * Gets a state by the index
		 * @param {integer} index
		 * @return {Object}
		 */
		History.getStateByIndex = function(index){
			// Prepare
			var State = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				State = History.savedStates[History.savedStates.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				State = History.savedStates[History.savedStates.length+index];
			}
			else {
				// Get from the beginning
				State = History.savedStates[index];
			}

			// Return State
			return State;
		};
		
		/**
		 * History.getCurrentIndex()
		 * Gets the current index
		 * @return (integer)
		*/
		History.getCurrentIndex = function(){
			// Prepare
			var index = null;
			
			// No states saved
			if(History.savedStates.length < 1) {
				index = 0;
			}
			else {
				index = History.savedStates.length-1;
			}
			return index;
		};

		// ====================================================================
		// Hash Helpers

		/**
		 * History.getHash()
		 * @param {Location=} location
		 * Gets the current document hash
		 * Note: unlike location.hash, this is guaranteed to return the escaped hash in all browsers
		 * @return {string}
		 */
		History.getHash = function(doc){
			var url = History.getLocationHref(doc),
				hash;
			hash = History.getHashByUrl(url);
			return hash;
		};

		/**
		 * History.unescapeHash()
		 * normalize and Unescape a Hash
		 * @param {String} hash
		 * @return {string}
		 */
		History.unescapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Unescape hash
			result = decodeURIComponent(result);

			// Return result
			return result;
		};

		/**
		 * History.normalizeHash()
		 * normalize a hash across browsers
		 * @return {string}
		 */
		History.normalizeHash = function(hash){
			// Prepare
			var result = hash.replace(/[^#]*#/,'').replace(/#.*/, '');

			// Return result
			return result;
		};

		/**
		 * History.setHash(hash)
		 * Sets the document hash
		 * @param {string} hash
		 * @return {History}
		 */
		History.setHash = function(hash,queue){
			// Prepare
			var State, pageUrl;

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.setHash: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.setHash,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Log
			//History.debug('History.setHash: called',hash);

			// Make Busy + Continue
			History.busy(true);

			// Check if hash is a state
			State = History.extractState(hash,true);
			if ( State && !History.emulated.pushState ) {
				// Hash is a state so skip the setHash
				//History.debug('History.setHash: Hash is a state so skipping the hash set with a direct pushState call',arguments);

				// PushState
				History.pushState(State.data,State.title,State.url,false);
			}
			else if ( History.getHash() !== hash ) {
				// Hash is a proper hash, so apply it

				// Handle browser bugs
				if ( History.bugs.setHash ) {
					// Fix Safari Bug https://bugs.webkit.org/show_bug.cgi?id=56249

					// Fetch the base page
					pageUrl = History.getPageUrl();

					// Safari hash apply
					History.pushState(null,null,pageUrl+'#'+hash,false);
				}
				else {
					// Normal hash apply
					document.location.hash = hash;
				}
			}

			// Chain
			return History;
		};

		/**
		 * History.escape()
		 * normalize and Escape a Hash
		 * @return {string}
		 */
		History.escapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Escape hash
			result = window.encodeURIComponent(result);

			// IE6 Escape Bug
			if ( !History.bugs.hashEscape ) {
				// Restore common parts
				result = result
					.replace(/\%21/g,'!')
					.replace(/\%26/g,'&')
					.replace(/\%3D/g,'=')
					.replace(/\%3F/g,'?');
			}

			// Return result
			return result;
		};

		/**
		 * History.getHashByUrl(url)
		 * Extracts the Hash from a URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getHashByUrl = function(url){
			// Extract the hash
			var hash = String(url)
				.replace(/([^#]*)#?([^#]*)#?(.*)/, '$2')
				;

			// Unescape hash
			hash = History.unescapeHash(hash);

			// Return hash
			return hash;
		};

		/**
		 * History.setTitle(title)
		 * Applies the title to the document
		 * @param {State} newState
		 * @return {Boolean}
		 */
		History.setTitle = function(newState){
			// Prepare
			var title = newState.title,
				firstState;

			// Initial
			if ( !title ) {
				firstState = History.getStateByIndex(0);
				if ( firstState && firstState.url === newState.url ) {
					title = firstState.title||History.options.initialTitle;
				}
			}

			// Apply
			try {
				document.getElementsByTagName('title')[0].innerHTML = title.replace('<','&lt;').replace('>','&gt;').replace(' & ',' &amp; ');
			}
			catch ( Exception ) { }
			document.title = title;

			// Chain
			return History;
		};


		// ====================================================================
		// Queueing

		/**
		 * History.queues
		 * The list of queues to use
		 * First In, First Out
		 */
		History.queues = [];

		/**
		 * History.busy(value)
		 * @param {boolean} value [optional]
		 * @return {boolean} busy
		 */
		History.busy = function(value){
			// Apply
			if ( typeof value !== 'undefined' ) {
				//History.debug('History.busy: changing ['+(History.busy.flag||false)+'] to ['+(value||false)+']', History.queues.length);
				History.busy.flag = value;
			}
			// Default
			else if ( typeof History.busy.flag === 'undefined' ) {
				History.busy.flag = false;
			}

			// Queue
			if ( !History.busy.flag ) {
				// Execute the next item in the queue
				clearTimeout(History.busy.timeout);
				var fireNext = function(){
					var i, queue, item;
					if ( History.busy.flag ) return;
					for ( i=History.queues.length-1; i >= 0; --i ) {
						queue = History.queues[i];
						if ( queue.length === 0 ) continue;
						item = queue.shift();
						History.fireQueueItem(item);
						History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
					}
				};
				History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
			}

			// Return
			return History.busy.flag;
		};

		/**
		 * History.busy.flag
		 */
		History.busy.flag = false;

		/**
		 * History.fireQueueItem(item)
		 * Fire a Queue Item
		 * @param {Object} item
		 * @return {Mixed} result
		 */
		History.fireQueueItem = function(item){
			return item.callback.apply(item.scope||History,item.args||[]);
		};

		/**
		 * History.pushQueue(callback,args)
		 * Add an item to the queue
		 * @param {Object} item [scope,callback,args,queue]
		 */
		History.pushQueue = function(item){
			// Prepare the queue
			History.queues[item.queue||0] = History.queues[item.queue||0]||[];

			// Add to the queue
			History.queues[item.queue||0].push(item);

			// Chain
			return History;
		};

		/**
		 * History.queue (item,queue), (func,queue), (func), (item)
		 * Either firs the item now if not busy, or adds it to the queue
		 */
		History.queue = function(item,queue){
			// Prepare
			if ( typeof item === 'function' ) {
				item = {
					callback: item
				};
			}
			if ( typeof queue !== 'undefined' ) {
				item.queue = queue;
			}

			// Handle
			if ( History.busy() ) {
				History.pushQueue(item);
			} else {
				History.fireQueueItem(item);
			}

			// Chain
			return History;
		};

		/**
		 * History.clearQueue()
		 * Clears the Queue
		 */
		History.clearQueue = function(){
			History.busy.flag = false;
			History.queues = [];
			return History;
		};


		// ====================================================================
		// IE Bug Fix

		/**
		 * History.stateChanged
		 * States whether or not the state has changed since the last double check was initialised
		 */
		History.stateChanged = false;

		/**
		 * History.doubleChecker
		 * Contains the timeout used for the double checks
		 */
		History.doubleChecker = false;

		/**
		 * History.doubleCheckComplete()
		 * Complete a double check
		 * @return {History}
		 */
		History.doubleCheckComplete = function(){
			// Update
			History.stateChanged = true;

			// Clear
			History.doubleCheckClear();

			// Chain
			return History;
		};

		/**
		 * History.doubleCheckClear()
		 * Clear a double check
		 * @return {History}
		 */
		History.doubleCheckClear = function(){
			// Clear
			if ( History.doubleChecker ) {
				clearTimeout(History.doubleChecker);
				History.doubleChecker = false;
			}

			// Chain
			return History;
		};

		/**
		 * History.doubleCheck()
		 * Create a double check
		 * @return {History}
		 */
		History.doubleCheck = function(tryAgain){
			// Reset
			History.stateChanged = false;
			History.doubleCheckClear();

			// Fix IE6,IE7 bug where calling history.back or history.forward does not actually change the hash (whereas doing it manually does)
			// Fix Safari 5 bug where sometimes the state does not change: https://bugs.webkit.org/show_bug.cgi?id=42940
			if ( History.bugs.ieDoubleCheck ) {
				// Apply Check
				History.doubleChecker = setTimeout(
					function(){
						History.doubleCheckClear();
						if ( !History.stateChanged ) {
							//History.debug('History.doubleCheck: State has not yet changed, trying again', arguments);
							// Re-Attempt
							tryAgain();
						}
						return true;
					},
					History.options.doubleCheckInterval
				);
			}

			// Chain
			return History;
		};


		// ====================================================================
		// Safari Bug Fix

		/**
		 * History.safariStatePoll()
		 * Poll the current state
		 * @return {History}
		 */
		History.safariStatePoll = function(){
			// Poll the URL

			// Get the Last State which has the new URL
			var
				urlState = History.extractState(History.getLocationHref()),
				newState;

			// Check for a difference
			if ( !History.isLastSavedState(urlState) ) {
				newState = urlState;
			}
			else {
				return;
			}

			// Check if we have a state with that url
			// If not create it
			if ( !newState ) {
				//History.debug('History.safariStatePoll: new');
				newState = History.createStateObject();
			}

			// Apply the New State
			//History.debug('History.safariStatePoll: trigger');
			History.Adapter.trigger(window,'popstate');

			// Chain
			return History;
		};


		// ====================================================================
		// State Aliases

		/**
		 * History.back(queue)
		 * Send the browser history back one item
		 * @param {Integer} queue [optional]
		 */
		History.back = function(queue){
			//History.debug('History.back: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.back: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.back,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.back(false);
			});

			// Go back
			history.go(-1);

			// End back closure
			return true;
		};

		/**
		 * History.forward(queue)
		 * Send the browser history forward one item
		 * @param {Integer} queue [optional]
		 */
		History.forward = function(queue){
			//History.debug('History.forward: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.forward: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.forward,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.forward(false);
			});

			// Go forward
			history.go(1);

			// End forward closure
			return true;
		};

		/**
		 * History.go(index,queue)
		 * Send the browser history back or forward index times
		 * @param {Integer} queue [optional]
		 */
		History.go = function(index,queue){
			//History.debug('History.go: called', arguments);

			// Prepare
			var i;

			// Handle
			if ( index > 0 ) {
				// Forward
				for ( i=1; i<=index; ++i ) {
					History.forward(queue);
				}
			}
			else if ( index < 0 ) {
				// Backward
				for ( i=-1; i>=index; --i ) {
					History.back(queue);
				}
			}
			else {
				throw new Error('History.go: History.go requires a positive or negative integer passed.');
			}

			// Chain
			return History;
		};


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * Provide Skeleton for HTML4 Browsers
			 */

			// Prepare
			var emptyFunction = function(){};
			History.pushState = History.pushState||emptyFunction;
			History.replaceState = History.replaceState||emptyFunction;
		} // History.emulated.pushState

		// Native pushState Implementation
		else {
			/*
			 * Use native HTML5 History API Implementation
			 */

			/**
			 * History.onPopState(event,extra)
			 * Refresh the Current State
			 */
			History.onPopState = function(event,extra){
				// Prepare
				var stateId = false, newState = false, currentHash, currentState;

				// Reset the double check
				History.doubleCheckComplete();
				
				var currentPath = document.location.pathname;
                var newPath = History.getShortUrl(History.getState().cleanUrl);

				// Check for a Hash, and handle apporiatly
				currentHash = History.getHash();
				 if ( currentHash && currentPath === newPath ) {
					// Expand Hash
					currentState = History.extractState(currentHash||History.getLocationHref(),true);
					if ( currentState ) {
						// We were able to parse it, it must be a State!
						// Let's forward to replaceState
						//History.debug('History.onPopState: state anchor', currentHash, currentState);
						History.replaceState(currentState.data, currentState.title, currentState.url, false);
					}
					else {
						// Traditional Anchor
						//History.debug('History.onPopState: traditional anchor', currentHash);
						History.Adapter.trigger(window,'anchorchange');
						History.busy(false);
					}

					// We don't care for hashes
					History.expectedStateId = false;
					return false;
				}

				// Ensure
				stateId = History.Adapter.extractEventData('state',event,extra) || false;

				// Fetch State
				if ( stateId ) {
					// Vanilla: Back/forward button was used
					newState = History.getStateById(stateId);
				}
				else if ( History.expectedStateId ) {
					// Vanilla: A new state was pushed, and popstate was called manually
					newState = History.getStateById(History.expectedStateId);
				}
				else {
					// Initial State
					newState = History.extractState(History.getLocationHref());
				}

				// The State did not exist in our store
				if ( !newState ) {
					// Regenerate the State
					newState = History.createStateObject(null,null,History.getLocationHref());
				}

				// Clean
				History.expectedStateId = false;

				// Check if we are the same state
				if ( History.isLastSavedState(newState) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onPopState: no change', newState, History.savedStates);
					History.busy(false);
					return false;
				}

				// Store the State
				History.storeState(newState);
				History.saveState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Fire Our Event
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// Return true
				return true;
			};
			History.Adapter.bind(window,'popstate',History.onPopState);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.pushState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.replaceState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End replaceState closure
				return true;
			};

		} // !History.emulated.pushState


		// ====================================================================
		// Initialise

		/**
		 * Load the Store
		 */
		if ( sessionStorage ) {
			// Fetch
			try {
				History.store = JSON.parse(sessionStorage.getItem('History.store'))||{};
			}
			catch ( err ) {
				History.store = {};
			}

			// Normalize
			History.normalizeStore();
		}
		else {
			// Default Load
			History.store = {};
			History.normalizeStore();
		}

		/**
		 * Clear Intervals on exit to prevent memory leaks
		 */
		History.Adapter.bind(window,"unload",History.clearAllIntervals);

		/**
		 * Create the initial State
		 */
		History.saveState(History.storeState(History.extractState(History.getLocationHref(),true)));

		/**
		 * Bind for Saving Store
		 */
		if ( sessionStorage ) {
			// When the page is closed
			History.onUnload = function(){
				// Prepare
				var	currentStore, item, currentStoreString;

				// Fetch
				try {
					currentStore = JSON.parse(sessionStorage.getItem('History.store'))||{};
				}
				catch ( err ) {
					currentStore = {};
				}

				// Ensure
				currentStore.idToState = currentStore.idToState || {};
				currentStore.urlToId = currentStore.urlToId || {};
				currentStore.stateToId = currentStore.stateToId || {};

				// Sync
				for ( item in History.idToState ) {
					if ( !History.idToState.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.idToState[item] = History.idToState[item];
				}
				for ( item in History.urlToId ) {
					if ( !History.urlToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.urlToId[item] = History.urlToId[item];
				}
				for ( item in History.stateToId ) {
					if ( !History.stateToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.stateToId[item] = History.stateToId[item];
				}

				// Update
				History.store = currentStore;
				History.normalizeStore();

				// In Safari, going into Private Browsing mode causes the
				// Session Storage object to still exist but if you try and use
				// or set any property/function of it it throws the exception
				// "QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to
				// add something to storage that exceeded the quota." infinitely
				// every second.
				currentStoreString = JSON.stringify(currentStore);
				try {
					// Store
					sessionStorage.setItem('History.store', currentStoreString);
				}
				catch (e) {
					if (e.code === DOMException.QUOTA_EXCEEDED_ERR) {
						if (sessionStorage.length) {
							// Workaround for a bug seen on iPads. Sometimes the quota exceeded error comes up and simply
							// removing/resetting the storage can work.
							sessionStorage.removeItem('History.store');
							sessionStorage.setItem('History.store', currentStoreString);
						} else {
							// Otherwise, we're probably private browsing in Safari, so we'll ignore the exception.
						}
					} else {
						throw e;
					}
				}
			};

			// For Internet Explorer
			History.intervalList.push(setInterval(History.onUnload,History.options.storeInterval));

			// For Other Browsers
			History.Adapter.bind(window,'beforeunload',History.onUnload);
			History.Adapter.bind(window,'unload',History.onUnload);

			// Both are enabled for consistency
		}

		// Non-Native pushState Implementation
		if ( !History.emulated.pushState ) {
			// Be aware, the following is only for native pushState implementations
			// If you are wanting to include something for all browsers
			// Then include it above this if block

			/**
			 * Setup Safari Fix
			 */
			if ( History.bugs.safariPoll ) {
				History.intervalList.push(setInterval(History.safariStatePoll, History.options.safariPollInterval));
			}

			/**
			 * Ensure Cross Browser Compatibility
			 */
			if ( navigator.vendor === 'Apple Computer, Inc.' || (navigator.appCodeName||'') === 'Mozilla' ) {
				/**
				 * Fix Safari HashChange Issue
				 */

				// Setup Alias
				History.Adapter.bind(window,'hashchange',function(){
					History.Adapter.trigger(window,'popstate');
				});

				// Initialise Alias
				if ( History.getHash() ) {
					History.Adapter.onDomLoad(function(){
						History.Adapter.trigger(window,'hashchange');
					});
				}
			}

		} // !History.emulated.pushState


	}; // History.initCore

	// Try to Initialise History
	if (!History.options || !History.options.delayInit) {
		History.init();
	}

})(window);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJqcXVlcnkuaGlzdG9yeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhpc3RvcnkuanMgalF1ZXJ5IEFkYXB0ZXJcbiAqIEBhdXRob3IgQmVuamFtaW4gQXJ0aHVyIEx1cHRvbiA8Y29udGFjdEBiYWx1cHRvbi5jb20+XG4gKiBAY29weXJpZ2h0IDIwMTAtMjAxMSBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cbiAqIEBsaWNlbnNlIE5ldyBCU0QgTGljZW5zZSA8aHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvQlNELz5cbiAqL1xuXG4vLyBDbG9zdXJlXG4oZnVuY3Rpb24od2luZG93LHVuZGVmaW5lZCl7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIExvY2FsaXNlIEdsb2JhbHNcblx0dmFyXG5cdFx0SGlzdG9yeSA9IHdpbmRvdy5IaXN0b3J5ID0gd2luZG93Lkhpc3Rvcnl8fHt9LFxuXHRcdGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG5cblx0Ly8gQ2hlY2sgRXhpc3RlbmNlXG5cdGlmICggdHlwZW9mIEhpc3RvcnkuQWRhcHRlciAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmpzIEFkYXB0ZXIgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQuLi4nKTtcblx0fVxuXG5cdC8vIEFkZCB0aGUgQWRhcHRlclxuXHRIaXN0b3J5LkFkYXB0ZXIgPSB7XG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5BZGFwdGVyLmJpbmQoZWwsZXZlbnQsY2FsbGJhY2spXG5cdFx0ICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWxcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBjdXN0b20gYW5kIHN0YW5kYXJkIGV2ZW50c1xuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG5cdFx0ICogQHJldHVybiB7dm9pZH1cblx0XHQgKi9cblx0XHRiaW5kOiBmdW5jdGlvbihlbCxldmVudCxjYWxsYmFjayl7XG5cdFx0XHRqUXVlcnkoZWwpLmJpbmQoZXZlbnQsY2FsbGJhY2spO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcihlbCxldmVudClcblx0XHQgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGN1c3RvbSBhbmQgc3RhbmRhcmQgZXZlbnRzXG5cdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBleHRyYSAtIGEgb2JqZWN0IG9mIGV4dHJhIGV2ZW50IGRhdGEgKG9wdGlvbmFsKVxuXHRcdCAqIEByZXR1cm4ge3ZvaWR9XG5cdFx0ICovXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oZWwsZXZlbnQsZXh0cmEpe1xuXHRcdFx0alF1ZXJ5KGVsKS50cmlnZ2VyKGV2ZW50LGV4dHJhKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5BZGFwdGVyLmV4dHJhY3RFdmVudERhdGEoa2V5LGV2ZW50LGV4dHJhKVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBrZXkgZm9yIHRoZSBldmVudCBkYXRhIHRvIGV4dHJhY3Rcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBjdXN0b20gYW5kIHN0YW5kYXJkIGV2ZW50c1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gZXh0cmEgLSBhIG9iamVjdCBvZiBleHRyYSBldmVudCBkYXRhIChvcHRpb25hbClcblx0XHQgKiBAcmV0dXJuIHttaXhlZH1cblx0XHQgKi9cblx0XHRleHRyYWN0RXZlbnREYXRhOiBmdW5jdGlvbihrZXksZXZlbnQsZXh0cmEpe1xuXHRcdFx0Ly8galF1ZXJ5IE5hdGl2ZSB0aGVuIGpRdWVyeSBDdXN0b21cblx0XHRcdHZhciByZXN1bHQgPSAoZXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50W2tleV0pIHx8IChleHRyYSAmJiBleHRyYVtrZXldKSB8fCB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5BZGFwdGVyLm9uRG9tTG9hZChjYWxsYmFjaylcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuXHRcdCAqIEByZXR1cm4ge3ZvaWR9XG5cdFx0ICovXG5cdFx0b25Eb21Mb2FkOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0alF1ZXJ5KGNhbGxiYWNrKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gVHJ5IGFuZCBJbml0aWFsaXNlIEhpc3Rvcnlcblx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRIaXN0b3J5LmluaXQoKTtcblx0fVxuXG59KSh3aW5kb3cpO1xuXG4vKipcbiAqIEhpc3RvcnkuanMgQ29yZVxuICogQGF1dGhvciBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cbiAqIEBjb3B5cmlnaHQgMjAxMC0yMDExIEJlbmphbWluIEFydGh1ciBMdXB0b24gPGNvbnRhY3RAYmFsdXB0b24uY29tPlxuICogQGxpY2Vuc2UgTmV3IEJTRCBMaWNlbnNlIDxodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9CU0QvPlxuICovXG5cbihmdW5jdGlvbih3aW5kb3csdW5kZWZpbmVkKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdC8vIEluaXRpYWxpc2VcblxuXHQvLyBMb2NhbGlzZSBHbG9iYWxzXG5cdHZhclxuXHRcdGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZXx8dW5kZWZpbmVkLCAvLyBQcmV2ZW50IGEgSlNMaW50IGNvbXBsYWluXG5cdFx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgdXNpbmcgdGhlIGNvcnJlY3QgZG9jdW1lbnRcblx0XHRuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLCAvLyBNYWtlIHN1cmUgd2UgYXJlIHVzaW5nIHRoZSBjb3JyZWN0IG5hdmlnYXRvclxuXHRcdHNlc3Npb25TdG9yYWdlID0gd2luZG93LnNlc3Npb25TdG9yYWdlfHxmYWxzZSwgLy8gc2Vzc2lvblN0b3JhZ2Vcblx0XHRzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQsXG5cdFx0Y2xlYXJUaW1lb3V0ID0gd2luZG93LmNsZWFyVGltZW91dCxcblx0XHRzZXRJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCxcblx0XHRjbGVhckludGVydmFsID0gd2luZG93LmNsZWFySW50ZXJ2YWwsXG5cdFx0SlNPTiA9IHdpbmRvdy5KU09OLFxuXHRcdGFsZXJ0ID0gd2luZG93LmFsZXJ0LFxuXHRcdEhpc3RvcnkgPSB3aW5kb3cuSGlzdG9yeSA9IHdpbmRvdy5IaXN0b3J5fHx7fSwgLy8gUHVibGljIEhpc3RvcnkgT2JqZWN0XG5cdFx0aGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5OyAvLyBPbGQgSGlzdG9yeSBPYmplY3RcblxuXHR0cnkge1xuXHRcdHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ1RFU1QnLCAnMScpO1xuXHRcdHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ1RFU1QnKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0c2Vzc2lvblN0b3JhZ2UgPSBmYWxzZTtcblx0fVxuXG5cdC8vIE1vb1Rvb2xzIENvbXBhdGliaWxpdHlcblx0SlNPTi5zdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeXx8SlNPTi5lbmNvZGU7XG5cdEpTT04ucGFyc2UgPSBKU09OLnBhcnNlfHxKU09OLmRlY29kZTtcblxuXHQvLyBDaGVjayBFeGlzdGVuY2Vcblx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuanMgQ29yZSBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZC4uLicpO1xuXHR9XG5cblx0Ly8gSW5pdGlhbGlzZSBIaXN0b3J5XG5cdEhpc3RvcnkuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXHRcdC8vIENoZWNrIExvYWQgU3RhdHVzIG9mIEFkYXB0ZXJcblx0XHRpZiAoIHR5cGVvZiBIaXN0b3J5LkFkYXB0ZXIgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIExvYWQgU3RhdHVzIG9mIENvcmVcblx0XHRpZiAoIHR5cGVvZiBIaXN0b3J5LmluaXRDb3JlICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdEhpc3RvcnkuaW5pdENvcmUoKTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBMb2FkIFN0YXR1cyBvZiBIVE1MNCBTdXBwb3J0XG5cdFx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0SHRtbDQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0SGlzdG9yeS5pbml0SHRtbDQoKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdC8vIEluaXRpYWxpc2UgQ29yZVxuXG5cdC8vIEluaXRpYWxpc2UgQ29yZVxuXHRIaXN0b3J5LmluaXRDb3JlID0gZnVuY3Rpb24ob3B0aW9ucyl7XG5cdFx0Ly8gSW5pdGlhbGlzZVxuXHRcdGlmICggdHlwZW9mIEhpc3RvcnkuaW5pdENvcmUuaW5pdGlhbGl6ZWQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0Ly8gQWxyZWFkeSBMb2FkZWRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRIaXN0b3J5LmluaXRDb3JlLmluaXRpYWxpemVkID0gdHJ1ZTtcblx0XHR9XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gT3B0aW9uc1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zXG5cdFx0ICogQ29uZmlndXJhYmxlIG9wdGlvbnNcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMgPSBIaXN0b3J5Lm9wdGlvbnN8fHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmhhc2hDaGFuZ2VJbnRlcnZhbFxuXHRcdCAqIEhvdyBsb25nIHNob3VsZCB0aGUgaW50ZXJ2YWwgYmUgYmVmb3JlIGhhc2hjaGFuZ2UgY2hlY2tzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmhhc2hDaGFuZ2VJbnRlcnZhbCA9IEhpc3Rvcnkub3B0aW9ucy5oYXNoQ2hhbmdlSW50ZXJ2YWwgfHwgMTAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLnNhZmFyaVBvbGxJbnRlcnZhbFxuXHRcdCAqIEhvdyBsb25nIHNob3VsZCB0aGUgaW50ZXJ2YWwgYmUgYmVmb3JlIHNhZmFyaSBwb2xsIGNoZWNrc1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5zYWZhcmlQb2xsSW50ZXJ2YWwgPSBIaXN0b3J5Lm9wdGlvbnMuc2FmYXJpUG9sbEludGVydmFsIHx8IDUwMDtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5kb3VibGVDaGVja0ludGVydmFsXG5cdFx0ICogSG93IGxvbmcgc2hvdWxkIHRoZSBpbnRlcnZhbCBiZSBiZWZvcmUgd2UgcGVyZm9ybSBhIGRvdWJsZSBjaGVja1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5kb3VibGVDaGVja0ludGVydmFsID0gSGlzdG9yeS5vcHRpb25zLmRvdWJsZUNoZWNrSW50ZXJ2YWwgfHwgNTAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmRpc2FibGVTdWlkXG5cdFx0ICogRm9yY2UgSGlzdG9yeSBub3QgdG8gYXBwZW5kIHN1aWRcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuZGlzYWJsZVN1aWQgPSBIaXN0b3J5Lm9wdGlvbnMuZGlzYWJsZVN1aWQgfHwgZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuc3RvcmVJbnRlcnZhbFxuXHRcdCAqIEhvdyBsb25nIHNob3VsZCB3ZSB3YWl0IGJldHdlZW4gc3RvcmUgY2FsbHNcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuc3RvcmVJbnRlcnZhbCA9IEhpc3Rvcnkub3B0aW9ucy5zdG9yZUludGVydmFsIHx8IDEwMDA7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuYnVzeURlbGF5XG5cdFx0ICogSG93IGxvbmcgc2hvdWxkIHdlIHdhaXQgYmV0d2VlbiBidXN5IGV2ZW50c1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5idXN5RGVsYXkgPSBIaXN0b3J5Lm9wdGlvbnMuYnVzeURlbGF5IHx8IDI1MDtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5kZWJ1Z1xuXHRcdCAqIElmIHRydWUgd2lsbCBlbmFibGUgZGVidWcgbWVzc2FnZXMgdG8gYmUgbG9nZ2VkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmRlYnVnID0gSGlzdG9yeS5vcHRpb25zLmRlYnVnIHx8IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmluaXRpYWxUaXRsZVxuXHRcdCAqIFdoYXQgaXMgdGhlIHRpdGxlIG9mIHRoZSBpbml0aWFsIHN0YXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmluaXRpYWxUaXRsZSA9IEhpc3Rvcnkub3B0aW9ucy5pbml0aWFsVGl0bGUgfHwgZG9jdW1lbnQudGl0bGU7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuaHRtbDRNb2RlXG5cdFx0ICogSWYgdHJ1ZSwgd2lsbCBmb3JjZSBIVE1sNCBtb2RlIChoYXNodGFncylcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuaHRtbDRNb2RlID0gSGlzdG9yeS5vcHRpb25zLmh0bWw0TW9kZSB8fCBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5kZWxheUluaXRcblx0XHQgKiBXYW50IHRvIG92ZXJyaWRlIGRlZmF1bHQgb3B0aW9ucyBhbmQgY2FsbCBpbml0IG1hbnVhbGx5LlxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5kZWxheUluaXQgPSBIaXN0b3J5Lm9wdGlvbnMuZGVsYXlJbml0IHx8IGZhbHNlO1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEludGVydmFsIHJlY29yZFxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5pbnRlcnZhbExpc3Rcblx0XHQgKiBMaXN0IG9mIGludGVydmFscyBzZXQsIHRvIGJlIGNsZWFyZWQgd2hlbiBkb2N1bWVudCBpcyB1bmxvYWRlZC5cblx0XHQgKi9cblx0XHRIaXN0b3J5LmludGVydmFsTGlzdCA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5jbGVhckFsbEludGVydmFsc1xuXHRcdCAqIENsZWFycyBhbGwgc2V0SW50ZXJ2YWwgaW5zdGFuY2VzLlxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuY2xlYXJBbGxJbnRlcnZhbHMgPSBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGksIGlsID0gSGlzdG9yeS5pbnRlcnZhbExpc3Q7XG5cdFx0XHRpZiAodHlwZW9mIGlsICE9PSBcInVuZGVmaW5lZFwiICYmIGlsICE9PSBudWxsKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBpbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwoaWxbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdEhpc3RvcnkuaW50ZXJ2YWxMaXN0ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIERlYnVnXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRlYnVnKG1lc3NhZ2UsLi4uKVxuXHRcdCAqIExvZ3MgdGhlIHBhc3NlZCBhcmd1bWVudHMgaWYgZGVidWcgZW5hYmxlZFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZGVidWcgPSBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKCAoSGlzdG9yeS5vcHRpb25zLmRlYnVnfHxmYWxzZSkgKSB7XG5cdFx0XHRcdEhpc3RvcnkubG9nLmFwcGx5KEhpc3RvcnksYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5sb2cobWVzc2FnZSwuLi4pXG5cdFx0ICogTG9ncyB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuXHRcdCAqL1xuXHRcdEhpc3RvcnkubG9nID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhclxuXHRcdFx0XHRjb25zb2xlRXhpc3RzID0gISh0eXBlb2YgY29uc29sZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGNvbnNvbGUubG9nID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgY29uc29sZS5sb2cuYXBwbHkgPT09ICd1bmRlZmluZWQnKSxcblx0XHRcdFx0dGV4dGFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9nJyksXG5cdFx0XHRcdG1lc3NhZ2UsXG5cdFx0XHRcdGksbixcblx0XHRcdFx0YXJncyxhcmdcblx0XHRcdFx0O1xuXG5cdFx0XHQvLyBXcml0ZSB0byBDb25zb2xlXG5cdFx0XHRpZiAoIGNvbnNvbGVFeGlzdHMgKSB7XG5cdFx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0XHRtZXNzYWdlID0gYXJncy5zaGlmdCgpO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBjb25zb2xlLmRlYnVnICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnLmFwcGx5KGNvbnNvbGUsW21lc3NhZ2UsYXJnc10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsW21lc3NhZ2UsYXJnc10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bWVzc2FnZSA9IChcIlxcblwiK2FyZ3VtZW50c1swXStcIlxcblwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV3JpdGUgdG8gbG9nXG5cdFx0XHRmb3IgKCBpPTEsbj1hcmd1bWVudHMubGVuZ3RoOyBpPG47ICsraSApIHtcblx0XHRcdFx0YXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0YXJnID0gSlNPTi5zdHJpbmdpZnkoYXJnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKCBFeGNlcHRpb24gKSB7XG5cdFx0XHRcdFx0XHQvLyBSZWN1cnNpdmUgT2JqZWN0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG1lc3NhZ2UgKz0gXCJcXG5cIithcmcrXCJcXG5cIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGV4dGFyZWFcblx0XHRcdGlmICggdGV4dGFyZWEgKSB7XG5cdFx0XHRcdHRleHRhcmVhLnZhbHVlICs9IG1lc3NhZ2UrXCJcXG4tLS0tLVxcblwiO1xuXHRcdFx0XHR0ZXh0YXJlYS5zY3JvbGxUb3AgPSB0ZXh0YXJlYS5zY3JvbGxIZWlnaHQgLSB0ZXh0YXJlYS5jbGllbnRIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBObyBUZXh0YXJlYSwgTm8gQ29uc29sZVxuXHRcdFx0ZWxzZSBpZiAoICFjb25zb2xlRXhpc3RzICkge1xuXHRcdFx0XHRhbGVydChtZXNzYWdlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gRW11bGF0ZWQgU3RhdHVzXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24oKVxuXHRcdCAqIEdldCdzIHRoZSBtYWpvciB2ZXJzaW9uIG9mIEludGVybmV0IEV4cGxvcmVyXG5cdFx0ICogQHJldHVybiB7aW50ZWdlcn1cblx0XHQgKiBAbGljZW5zZSBQdWJsaWMgRG9tYWluXG5cdFx0ICogQGF1dGhvciBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cblx0XHQgKiBAYXV0aG9yIEphbWVzIFBhZG9sc2V5IDxodHRwczovL2dpc3QuZ2l0aHViLmNvbS81Mjc2ODM+XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciByZXN1bHQgPSBIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24uY2FjaGVkID1cblx0XHRcdFx0XHQodHlwZW9mIEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbi5jYWNoZWQgIT09ICd1bmRlZmluZWQnKVxuXHRcdFx0XHQ/XHRIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24uY2FjaGVkXG5cdFx0XHRcdDpcdChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0dmFyIHYgPSAzLFxuXHRcdFx0XHRcdFx0XHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdFx0XHRcdFx0XHRcdGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCAoZGl2LmlubmVySFRNTCA9ICc8IS0tW2lmIGd0IElFICcgKyAoKyt2KSArICddPjxpPjwvaT48IVtlbmRpZl0tLT4nKSAmJiBhbGxbMF0gKSB7fVxuXHRcdFx0XHRcdFx0cmV0dXJuICh2ID4gNCkgPyB2IDogZmFsc2U7XG5cdFx0XHRcdFx0fSkoKVxuXHRcdFx0XHQ7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3JlcigpXG5cdFx0ICogQXJlIHdlIHVzaW5nIEludGVybmV0IEV4cGxvcmVyP1xuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0ICogQGxpY2Vuc2UgUHVibGljIERvbWFpblxuXHRcdCAqIEBhdXRob3IgQmVuamFtaW4gQXJ0aHVyIEx1cHRvbiA8Y29udGFjdEBiYWx1cHRvbi5jb20+XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHJlc3VsdCA9XG5cdFx0XHRcdEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyLmNhY2hlZCA9XG5cdFx0XHRcdCh0eXBlb2YgSGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIuY2FjaGVkICE9PSAndW5kZWZpbmVkJylcblx0XHRcdFx0XHQ/XHRIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3Jlci5jYWNoZWRcblx0XHRcdFx0XHQ6XHRCb29sZWFuKEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbigpKVxuXHRcdFx0XHQ7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmVtdWxhdGVkXG5cdFx0ICogV2hpY2ggZmVhdHVyZXMgcmVxdWlyZSBlbXVsYXRpbmc/XG5cdFx0ICovXG5cblx0XHRpZiAoSGlzdG9yeS5vcHRpb25zLmh0bWw0TW9kZSkge1xuXHRcdFx0SGlzdG9yeS5lbXVsYXRlZCA9IHtcblx0XHRcdFx0cHVzaFN0YXRlIDogdHJ1ZSxcblx0XHRcdFx0aGFzaENoYW5nZTogdHJ1ZVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRlbHNlIHtcblxuXHRcdFx0SGlzdG9yeS5lbXVsYXRlZCA9IHtcblx0XHRcdFx0cHVzaFN0YXRlOiAhQm9vbGVhbihcblx0XHRcdFx0XHR3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgJiYgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlXG5cdFx0XHRcdFx0JiYgIShcblx0XHRcdFx0XHRcdCgvIE1vYmlsZVxcLyhbMS03XVthLXpdfCg4KFthYmNkZV18ZigxWzAtOF0pKSkpL2kpLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgLyogZGlzYWJsZSBmb3IgdmVyc2lvbnMgb2YgaU9TIGJlZm9yZSB2ZXJzaW9uIDQuMyAoOEYxOTApICovXG5cdFx0XHRcdFx0XHR8fCAoL0FwcGxlV2ViS2l0XFwvNShbMC0yXXwzWzAtMl0pL2kpLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgLyogZGlzYWJsZSBmb3IgdGhlIG1lcmN1cnkgaU9TIGJyb3dzZXIsIG9yIGF0IGxlYXN0IG9sZGVyIHZlcnNpb25zIG9mIHRoZSB3ZWJraXQgZW5naW5lICovXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpLFxuXHRcdFx0XHRoYXNoQ2hhbmdlOiBCb29sZWFuKFxuXHRcdFx0XHRcdCEoKCdvbmhhc2hjaGFuZ2UnIGluIHdpbmRvdykgfHwgKCdvbmhhc2hjaGFuZ2UnIGluIGRvY3VtZW50KSlcblx0XHRcdFx0XHR8fFxuXHRcdFx0XHRcdChIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3JlcigpICYmIEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbigpIDwgOClcblx0XHRcdFx0KVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmVuYWJsZWRcblx0XHQgKiBJcyBIaXN0b3J5IGVuYWJsZWQ/XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5lbmFibGVkID0gIUhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5idWdzXG5cdFx0ICogV2hpY2ggYnVncyBhcmUgcHJlc2VudFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuYnVncyA9IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogU2FmYXJpIDUgYW5kIFNhZmFyaSBpT1MgNCBmYWlsIHRvIHJldHVybiB0byB0aGUgY29ycmVjdCBzdGF0ZSBvbmNlIGEgaGFzaCBpcyByZXBsYWNlZCBieSBhIGByZXBsYWNlU3RhdGVgIGNhbGxcblx0XHRcdCAqIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD01NjI0OVxuXHRcdFx0ICovXG5cdFx0XHRzZXRIYXNoOiBCb29sZWFuKCFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSAmJiBuYXZpZ2F0b3IudmVuZG9yID09PSAnQXBwbGUgQ29tcHV0ZXIsIEluYy4nICYmIC9BcHBsZVdlYktpdFxcLzUoWzAtMl18M1swLTNdKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSksXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2FmYXJpIDUgYW5kIFNhZmFyaSBpT1MgNCBzb21ldGltZXMgZmFpbCB0byBhcHBseSB0aGUgc3RhdGUgY2hhbmdlIHVuZGVyIGJ1c3kgY29uZGl0aW9uc1xuXHRcdFx0ICogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTQyOTQwXG5cdFx0XHQgKi9cblx0XHRcdHNhZmFyaVBvbGw6IEJvb2xlYW4oIUhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICYmIG5hdmlnYXRvci52ZW5kb3IgPT09ICdBcHBsZSBDb21wdXRlciwgSW5jLicgJiYgL0FwcGxlV2ViS2l0XFwvNShbMC0yXXwzWzAtM10pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNU0lFIDYgYW5kIDcgc29tZXRpbWVzIGRvIG5vdCBhcHBseSBhIGhhc2ggZXZlbiBpdCB3YXMgdG9sZCB0byAocmVxdWlyaW5nIGEgc2Vjb25kIGNhbGwgdG8gdGhlIGFwcGx5IGZ1bmN0aW9uKVxuXHRcdFx0ICovXG5cdFx0XHRpZURvdWJsZUNoZWNrOiBCb29sZWFuKEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyKCkgJiYgSGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uKCkgPCA4KSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNU0lFIDYgcmVxdWlyZXMgdGhlIGVudGlyZSBoYXNoIHRvIGJlIGVuY29kZWQgZm9yIHRoZSBoYXNoZXMgdG8gdHJpZ2dlciB0aGUgb25IYXNoQ2hhbmdlIGV2ZW50XG5cdFx0XHQgKi9cblx0XHRcdGhhc2hFc2NhcGU6IEJvb2xlYW4oSGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIoKSAmJiBIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24oKSA8IDcpXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNFbXB0eU9iamVjdChvYmopXG5cdFx0ICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgT2JqZWN0IGlzIEVtcHR5XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggb2JqLmhhc093blByb3BlcnR5KG5hbWUpICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuY2xvbmVPYmplY3Qob2JqKVxuXHRcdCAqIENsb25lcyBhIG9iamVjdCBhbmQgZWxpbWluYXRlIGFsbCByZWZlcmVuY2VzIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0c1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5jbG9uZU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0dmFyIGhhc2gsbmV3T2JqO1xuXHRcdFx0aWYgKCBvYmogKSB7XG5cdFx0XHRcdGhhc2ggPSBKU09OLnN0cmluZ2lmeShvYmopO1xuXHRcdFx0XHRuZXdPYmogPSBKU09OLnBhcnNlKGhhc2gpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG5ld09iaiA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ld09iajtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFVSTCBIZWxwZXJzXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldFJvb3RVcmwoKVxuXHRcdCAqIFR1cm5zIFwiaHR0cDovL215c2l0ZS5jb20vZGlyL3BhZ2UuaHRtbD9hc2RcIiBpbnRvIFwiaHR0cDovL215c2l0ZS5jb21cIlxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gcm9vdFVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0Um9vdFVybCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdHZhciByb290VXJsID0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wrJy8vJysoZG9jdW1lbnQubG9jYXRpb24uaG9zdG5hbWV8fGRvY3VtZW50LmxvY2F0aW9uLmhvc3QpO1xuXHRcdFx0aWYgKCBkb2N1bWVudC5sb2NhdGlvbi5wb3J0fHxmYWxzZSApIHtcblx0XHRcdFx0cm9vdFVybCArPSAnOicrZG9jdW1lbnQubG9jYXRpb24ucG9ydDtcblx0XHRcdH1cblx0XHRcdHJvb3RVcmwgKz0gJy8nO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiByb290VXJsO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEJhc2VIcmVmKClcblx0XHQgKiBGZXRjaGVzIHRoZSBgaHJlZmAgYXR0cmlidXRlIG9mIHRoZSBgPGJhc2UgaHJlZj1cIi4uLlwiPmAgZWxlbWVudCBpZiBpdCBleGlzdHNcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2VIcmVmXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRCYXNlSHJlZiA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdHZhclxuXHRcdFx0XHRiYXNlRWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmFzZScpLFxuXHRcdFx0XHRiYXNlRWxlbWVudCA9IG51bGwsXG5cdFx0XHRcdGJhc2VIcmVmID0gJyc7XG5cblx0XHRcdC8vIFRlc3QgZm9yIEJhc2UgRWxlbWVudFxuXHRcdFx0aWYgKCBiYXNlRWxlbWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHQvLyBQcmVwYXJlIGZvciBCYXNlIEVsZW1lbnRcblx0XHRcdFx0YmFzZUVsZW1lbnQgPSBiYXNlRWxlbWVudHNbMF07XG5cdFx0XHRcdGJhc2VIcmVmID0gYmFzZUVsZW1lbnQuaHJlZi5yZXBsYWNlKC9bXlxcL10rJC8sJycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGp1c3QgdHJhaWxpbmcgc2xhc2hcblx0XHRcdGJhc2VIcmVmID0gYmFzZUhyZWYucmVwbGFjZSgvXFwvKyQvLCcnKTtcblx0XHRcdGlmICggYmFzZUhyZWYgKSBiYXNlSHJlZiArPSAnLyc7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGJhc2VIcmVmO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEJhc2VVcmwoKVxuXHRcdCAqIEZldGNoZXMgdGhlIGJhc2VIcmVmIG9yIGJhc2VQYWdlVXJsIG9yIHJvb3RVcmwgKHdoaWNoZXZlciBvbmUgZXhpc3RzIGZpcnN0KVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gYmFzZVVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0QmFzZVVybCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdHZhciBiYXNlVXJsID0gSGlzdG9yeS5nZXRCYXNlSHJlZigpfHxIaXN0b3J5LmdldEJhc2VQYWdlVXJsKCl8fEhpc3RvcnkuZ2V0Um9vdFVybCgpO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBiYXNlVXJsO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldFBhZ2VVcmwoKVxuXHRcdCAqIEZldGNoZXMgdGhlIFVSTCBvZiB0aGUgY3VycmVudCBwYWdlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBwYWdlVXJsXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRQYWdlVXJsID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIEZldGNoXG5cdFx0XHR2YXJcblx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlKGZhbHNlLGZhbHNlKSxcblx0XHRcdFx0c3RhdGVVcmwgPSAoU3RhdGV8fHt9KS51cmx8fEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCksXG5cdFx0XHRcdHBhZ2VVcmw7XG5cblx0XHRcdC8vIENyZWF0ZVxuXHRcdFx0cGFnZVVybCA9IHN0YXRlVXJsLnJlcGxhY2UoL1xcLyskLywnJykucmVwbGFjZSgvW15cXC9dKyQvLGZ1bmN0aW9uKHBhcnQsaW5kZXgsc3RyaW5nKXtcblx0XHRcdFx0cmV0dXJuICgvXFwuLykudGVzdChwYXJ0KSA/IHBhcnQgOiBwYXJ0KycvJztcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBwYWdlVXJsO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEJhc2VQYWdlVXJsKClcblx0XHQgKiBGZXRjaGVzIHRoZSBVcmwgb2YgdGhlIGRpcmVjdG9yeSBvZiB0aGUgY3VycmVudCBwYWdlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBiYXNlUGFnZVVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0QmFzZVBhZ2VVcmwgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ3JlYXRlXG5cdFx0XHR2YXIgYmFzZVBhZ2VVcmwgPSAoSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSkucmVwbGFjZSgvWyNcXD9dLiovLCcnKS5yZXBsYWNlKC9bXlxcL10rJC8sZnVuY3Rpb24ocGFydCxpbmRleCxzdHJpbmcpe1xuXHRcdFx0XHRyZXR1cm4gKC9bXlxcL10kLykudGVzdChwYXJ0KSA/ICcnIDogcGFydDtcblx0XHRcdH0pLnJlcGxhY2UoL1xcLyskLywnJykrJy8nO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBiYXNlUGFnZVVybDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRGdWxsVXJsKHVybClcblx0XHQgKiBFbnN1cmVzIHRoYXQgd2UgaGF2ZSBhbiBhYnNvbHV0ZSBVUkwgYW5kIG5vdCBhIHJlbGF0aXZlIFVSTFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93QmFzZUhyZWZcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IGZ1bGxVcmxcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldEZ1bGxVcmwgPSBmdW5jdGlvbih1cmwsYWxsb3dCYXNlSHJlZil7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgZnVsbFVybCA9IHVybCwgZmlyc3RDaGFyID0gdXJsLnN1YnN0cmluZygwLDEpO1xuXHRcdFx0YWxsb3dCYXNlSHJlZiA9ICh0eXBlb2YgYWxsb3dCYXNlSHJlZiA9PT0gJ3VuZGVmaW5lZCcpID8gdHJ1ZSA6IGFsbG93QmFzZUhyZWY7XG5cblx0XHRcdC8vIENoZWNrXG5cdFx0XHRpZiAoIC9bYS16XStcXDpcXC9cXC8vLnRlc3QodXJsKSApIHtcblx0XHRcdFx0Ly8gRnVsbCBVUkxcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBmaXJzdENoYXIgPT09ICcvJyApIHtcblx0XHRcdFx0Ly8gUm9vdCBVUkxcblx0XHRcdFx0ZnVsbFVybCA9IEhpc3RvcnkuZ2V0Um9vdFVybCgpK3VybC5yZXBsYWNlKC9eXFwvKy8sJycpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGZpcnN0Q2hhciA9PT0gJyMnICkge1xuXHRcdFx0XHQvLyBBbmNob3IgVVJMXG5cdFx0XHRcdGZ1bGxVcmwgPSBIaXN0b3J5LmdldFBhZ2VVcmwoKS5yZXBsYWNlKC8jLiovLCcnKSt1cmw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggZmlyc3RDaGFyID09PSAnPycgKSB7XG5cdFx0XHRcdC8vIFF1ZXJ5IFVSTFxuXHRcdFx0XHRmdWxsVXJsID0gSGlzdG9yeS5nZXRQYWdlVXJsKCkucmVwbGFjZSgvW1xcPyNdLiovLCcnKSt1cmw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gUmVsYXRpdmUgVVJMXG5cdFx0XHRcdGlmICggYWxsb3dCYXNlSHJlZiApIHtcblx0XHRcdFx0XHRmdWxsVXJsID0gSGlzdG9yeS5nZXRCYXNlVXJsKCkrdXJsLnJlcGxhY2UoL14oXFwuXFwvKSsvLCcnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmdWxsVXJsID0gSGlzdG9yeS5nZXRCYXNlUGFnZVVybCgpK3VybC5yZXBsYWNlKC9eKFxcLlxcLykrLywnJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gV2UgaGF2ZSBhbiBpZiBjb25kaXRpb24gYWJvdmUgYXMgd2UgZG8gbm90IHdhbnQgaGFzaGVzXG5cdFx0XHRcdC8vIHdoaWNoIGFyZSByZWxhdGl2ZSB0byB0aGUgYmFzZUhyZWYgaW4gb3VyIFVSTHNcblx0XHRcdFx0Ly8gYXMgaWYgdGhlIGJhc2VIcmVmIGNoYW5nZXMsIHRoZW4gYWxsIG91ciBib29rbWFya3Ncblx0XHRcdFx0Ly8gd291bGQgbm93IHBvaW50IHRvIGRpZmZlcmVudCBsb2NhdGlvbnNcblx0XHRcdFx0Ly8gd2hlcmVhcyB0aGUgYmFzZVBhZ2VVcmwgd2lsbCBhbHdheXMgc3RheSB0aGUgc2FtZVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBmdWxsVXJsLnJlcGxhY2UoL1xcIyQvLCcnKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRTaG9ydFVybCh1cmwpXG5cdFx0ICogRW5zdXJlcyB0aGF0IHdlIGhhdmUgYSByZWxhdGl2ZSBVUkwgYW5kIG5vdCBhIGFic29sdXRlIFVSTFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0U2hvcnRVcmwgPSBmdW5jdGlvbih1cmwpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIHNob3J0VXJsID0gdXJsLCBiYXNlVXJsID0gSGlzdG9yeS5nZXRCYXNlVXJsKCksIHJvb3RVcmwgPSBIaXN0b3J5LmdldFJvb3RVcmwoKTtcblxuXHRcdFx0Ly8gVHJpbSBiYXNlVXJsXG5cdFx0XHRpZiAoIEhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICkge1xuXHRcdFx0XHQvLyBXZSBhcmUgaW4gYSBpZiBzdGF0ZW1lbnQgYXMgd2hlbiBwdXNoU3RhdGUgaXMgbm90IGVtdWxhdGVkXG5cdFx0XHRcdC8vIFRoZSBhY3R1YWwgdXJsIHRoZXNlIHNob3J0IHVybHMgYXJlIHJlbGF0aXZlIHRvIGNhbiBjaGFuZ2Vcblx0XHRcdFx0Ly8gU28gd2l0aGluIHRoZSBzYW1lIHNlc3Npb24sIHdlIHRoZSB1cmwgbWF5IGVuZCB1cCBzb21ld2hlcmUgZGlmZmVyZW50XG5cdFx0XHRcdHNob3J0VXJsID0gc2hvcnRVcmwucmVwbGFjZShiYXNlVXJsLCcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJpbSByb290VXJsXG5cdFx0XHRzaG9ydFVybCA9IHNob3J0VXJsLnJlcGxhY2Uocm9vdFVybCwnLycpO1xuXG5cdFx0XHQvLyBFbnN1cmUgd2UgY2FuIHN0aWxsIGRldGVjdCBpdCBhcyBhIHN0YXRlXG5cdFx0XHRpZiAoIEhpc3RvcnkuaXNUcmFkaXRpb25hbEFuY2hvcihzaG9ydFVybCkgKSB7XG5cdFx0XHRcdHNob3J0VXJsID0gJy4vJytzaG9ydFVybDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYW4gSXRcblx0XHRcdHNob3J0VXJsID0gc2hvcnRVcmwucmVwbGFjZSgvXihcXC5cXC8pKy9nLCcuLycpLnJlcGxhY2UoL1xcIyQvLCcnKTtcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gc2hvcnRVcmw7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKGRvY3VtZW50KVxuXHRcdCAqIFJldHVybnMgYSBub3JtYWxpemVkIHZlcnNpb24gb2YgZG9jdW1lbnQubG9jYXRpb24uaHJlZlxuXHRcdCAqIGFjY291bnRpbmcgZm9yIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzLCBldGMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIFVSTCB3aWxsIGJlIFVSSS1lbmNvZGVkIGFuZCB3aWxsIGluY2x1ZGUgdGhlIGhhc2hcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkb2N1bWVudFxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gdXJsXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYgPSBmdW5jdGlvbihkb2MpIHtcblx0XHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdFx0Ly8gbW9zdCBvZiB0aGUgdGltZSwgdGhpcyB3aWxsIGJlIHRydWVcblx0XHRcdGlmIChkb2MuVVJMID09PSBkb2MubG9jYXRpb24uaHJlZilcblx0XHRcdFx0cmV0dXJuIGRvYy5sb2NhdGlvbi5ocmVmO1xuXG5cdFx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHdlYmtpdCBVUkktZGVjb2RlIGRvY3VtZW50LmxvY2F0aW9uLmhyZWZcblx0XHRcdC8vIGJ1dCB0aGV5IGxlYXZlIGRvY3VtZW50LlVSTCBpbiBhbiBlbmNvZGVkIHN0YXRlXG5cdFx0XHRpZiAoZG9jLmxvY2F0aW9uLmhyZWYgPT09IGRlY29kZVVSSUNvbXBvbmVudChkb2MuVVJMKSlcblx0XHRcdFx0cmV0dXJuIGRvYy5VUkw7XG5cblx0XHRcdC8vIEZGIDMuNiBvbmx5IHVwZGF0ZXMgZG9jdW1lbnQuVVJMIHdoZW4gYSBwYWdlIGlzIHJlbG9hZGVkXG5cdFx0XHQvLyBkb2N1bWVudC5sb2NhdGlvbi5ocmVmIGlzIHVwZGF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoZG9jLmxvY2F0aW9uLmhhc2ggJiYgZGVjb2RlVVJJQ29tcG9uZW50KGRvYy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoL15bXiNdKy8sIFwiXCIpKSA9PT0gZG9jLmxvY2F0aW9uLmhhc2gpXG5cdFx0XHRcdHJldHVybiBkb2MubG9jYXRpb24uaHJlZjtcblxuXHRcdFx0aWYgKGRvYy5VUkwuaW5kZXhPZignIycpID09IC0xICYmIGRvYy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKSAhPSAtMSlcblx0XHRcdFx0cmV0dXJuIGRvYy5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZG9jLlVSTCB8fCBkb2MubG9jYXRpb24uaHJlZjtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFN0YXRlIFN0b3JhZ2VcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc3RvcmVcblx0XHQgKiBUaGUgc3RvcmUgZm9yIGFsbCBzZXNzaW9uIHNwZWNpZmljIGRhdGFcblx0XHQgKi9cblx0XHRIaXN0b3J5LnN0b3JlID0ge307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmlkVG9TdGF0ZVxuXHRcdCAqIDEtMTogU3RhdGUgSUQgdG8gU3RhdGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pZFRvU3RhdGUgPSBIaXN0b3J5LmlkVG9TdGF0ZXx8e307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnN0YXRlVG9JZFxuXHRcdCAqIDEtMTogU3RhdGUgU3RyaW5nIHRvIFN0YXRlIElEXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zdGF0ZVRvSWQgPSBIaXN0b3J5LnN0YXRlVG9JZHx8e307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnVybFRvSWRcblx0XHQgKiAxLTE6IFN0YXRlIFVSTCB0byBTdGF0ZSBJRFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkudXJsVG9JZCA9IEhpc3RvcnkudXJsVG9JZHx8e307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnN0b3JlZFN0YXRlc1xuXHRcdCAqIFN0b3JlIHRoZSBzdGF0ZXMgaW4gYW4gYXJyYXlcblx0XHQgKi9cblx0XHRIaXN0b3J5LnN0b3JlZFN0YXRlcyA9IEhpc3Rvcnkuc3RvcmVkU3RhdGVzfHxbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc2F2ZWRTdGF0ZXNcblx0XHQgKiBTYXZlZCB0aGUgc3RhdGVzIGluIGFuIGFycmF5XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYXZlZFN0YXRlcyA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXN8fFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5ub3JhbWxpemVTdG9yZSgpXG5cdFx0ICogTm9yYW1saXplIHRoZSBzdG9yZSBieSBhZGRpbmcgbmVjZXNzYXJ5IHZhbHVlc1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUgPSBmdW5jdGlvbigpe1xuXHRcdFx0SGlzdG9yeS5zdG9yZS5pZFRvU3RhdGUgPSBIaXN0b3J5LnN0b3JlLmlkVG9TdGF0ZXx8e307XG5cdFx0XHRIaXN0b3J5LnN0b3JlLnVybFRvSWQgPSBIaXN0b3J5LnN0b3JlLnVybFRvSWR8fHt9O1xuXHRcdFx0SGlzdG9yeS5zdG9yZS5zdGF0ZVRvSWQgPSBIaXN0b3J5LnN0b3JlLnN0YXRlVG9JZHx8e307XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0U3RhdGUoKVxuXHRcdCAqIEdldCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSwgdGl0bGUgYW5kIHVybCBvZiB0aGUgY3VycmVudCBzdGF0ZVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZnJpZW5kbHlcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNyZWF0ZVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gU3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldFN0YXRlID0gZnVuY3Rpb24oZnJpZW5kbHksY3JlYXRlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdGlmICggdHlwZW9mIGZyaWVuZGx5ID09PSAndW5kZWZpbmVkJyApIHsgZnJpZW5kbHkgPSB0cnVlOyB9XG5cdFx0XHRpZiAoIHR5cGVvZiBjcmVhdGUgPT09ICd1bmRlZmluZWQnICkgeyBjcmVhdGUgPSB0cnVlOyB9XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHR2YXIgU3RhdGUgPSBIaXN0b3J5LmdldExhc3RTYXZlZFN0YXRlKCk7XG5cblx0XHRcdC8vIENyZWF0ZVxuXHRcdFx0aWYgKCAhU3RhdGUgJiYgY3JlYXRlICkge1xuXHRcdFx0XHRTdGF0ZSA9IEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRqdXN0XG5cdFx0XHRpZiAoIGZyaWVuZGx5ICkge1xuXHRcdFx0XHRTdGF0ZSA9IEhpc3RvcnkuY2xvbmVPYmplY3QoU3RhdGUpO1xuXHRcdFx0XHRTdGF0ZS51cmwgPSBTdGF0ZS5jbGVhblVybHx8U3RhdGUudXJsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBTdGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRJZEJ5U3RhdGUoU3RhdGUpXG5cdFx0ICogR2V0cyBhIElEIGZvciBhIFN0YXRlXG5cdFx0ICogQHBhcmFtIHtTdGF0ZX0gbmV3U3RhdGVcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRJZEJ5U3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSl7XG5cblx0XHRcdC8vIEZldGNoIElEXG5cdFx0XHR2YXIgaWQgPSBIaXN0b3J5LmV4dHJhY3RJZChuZXdTdGF0ZS51cmwpLFxuXHRcdFx0XHRzdHI7XG5cblx0XHRcdGlmICggIWlkICkge1xuXHRcdFx0XHQvLyBGaW5kIElEIHZpYSBTdGF0ZSBTdHJpbmdcblx0XHRcdFx0c3RyID0gSGlzdG9yeS5nZXRTdGF0ZVN0cmluZyhuZXdTdGF0ZSk7XG5cdFx0XHRcdGlmICggdHlwZW9mIEhpc3Rvcnkuc3RhdGVUb0lkW3N0cl0gIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdGlkID0gSGlzdG9yeS5zdGF0ZVRvSWRbc3RyXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggdHlwZW9mIEhpc3Rvcnkuc3RvcmUuc3RhdGVUb0lkW3N0cl0gIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdGlkID0gSGlzdG9yeS5zdG9yZS5zdGF0ZVRvSWRbc3RyXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBHZW5lcmF0ZSBhIG5ldyBJRFxuXHRcdFx0XHRcdHdoaWxlICggdHJ1ZSApIHtcblx0XHRcdFx0XHRcdGlkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXEQvZywnJyk7XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBIaXN0b3J5LmlkVG9TdGF0ZVtpZF0gPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBIaXN0b3J5LnN0b3JlLmlkVG9TdGF0ZVtpZF0gPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBcHBseSB0aGUgbmV3IFN0YXRlIHRvIHRoZSBJRFxuXHRcdFx0XHRcdEhpc3Rvcnkuc3RhdGVUb0lkW3N0cl0gPSBpZDtcblx0XHRcdFx0XHRIaXN0b3J5LmlkVG9TdGF0ZVtpZF0gPSBuZXdTdGF0ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gSURcblx0XHRcdHJldHVybiBpZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5ub3JtYWxpemVTdGF0ZShTdGF0ZSlcblx0XHQgKiBFeHBhbmRzIGEgU3RhdGUgT2JqZWN0XG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFN0YXRlXG5cdFx0ICogQHJldHVybiB7b2JqZWN0fVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkubm9ybWFsaXplU3RhdGUgPSBmdW5jdGlvbihvbGRTdGF0ZSl7XG5cdFx0XHQvLyBWYXJpYWJsZXNcblx0XHRcdHZhciBuZXdTdGF0ZSwgZGF0YU5vdEVtcHR5O1xuXG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRpZiAoICFvbGRTdGF0ZSB8fCAodHlwZW9mIG9sZFN0YXRlICE9PSAnb2JqZWN0JykgKSB7XG5cdFx0XHRcdG9sZFN0YXRlID0ge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrXG5cdFx0XHRpZiAoIHR5cGVvZiBvbGRTdGF0ZS5ub3JtYWxpemVkICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0cmV0dXJuIG9sZFN0YXRlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGp1c3Rcblx0XHRcdGlmICggIW9sZFN0YXRlLmRhdGEgfHwgKHR5cGVvZiBvbGRTdGF0ZS5kYXRhICE9PSAnb2JqZWN0JykgKSB7XG5cdFx0XHRcdG9sZFN0YXRlLmRhdGEgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdG5ld1N0YXRlID0ge307XG5cdFx0XHRuZXdTdGF0ZS5ub3JtYWxpemVkID0gdHJ1ZTtcblx0XHRcdG5ld1N0YXRlLnRpdGxlID0gb2xkU3RhdGUudGl0bGV8fCcnO1xuXHRcdFx0bmV3U3RhdGUudXJsID0gSGlzdG9yeS5nZXRGdWxsVXJsKG9sZFN0YXRlLnVybD9vbGRTdGF0ZS51cmw6KEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpKTtcblx0XHRcdG5ld1N0YXRlLmhhc2ggPSBIaXN0b3J5LmdldFNob3J0VXJsKG5ld1N0YXRlLnVybCk7XG5cdFx0XHRuZXdTdGF0ZS5kYXRhID0gSGlzdG9yeS5jbG9uZU9iamVjdChvbGRTdGF0ZS5kYXRhKTtcblxuXHRcdFx0Ly8gRmV0Y2ggSURcblx0XHRcdG5ld1N0YXRlLmlkID0gSGlzdG9yeS5nZXRJZEJ5U3RhdGUobmV3U3RhdGUpO1xuXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRcdC8vIENsZWFuIHRoZSBVUkxcblx0XHRcdG5ld1N0YXRlLmNsZWFuVXJsID0gbmV3U3RhdGUudXJsLnJlcGxhY2UoL1xcPz9cXCZfc3VpZC4qLywnJyk7XG5cdFx0XHRuZXdTdGF0ZS51cmwgPSBuZXdTdGF0ZS5jbGVhblVybDtcblxuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgbW9yZSB0aGFuIGp1c3QgYSB1cmxcblx0XHRcdGRhdGFOb3RFbXB0eSA9ICFIaXN0b3J5LmlzRW1wdHlPYmplY3QobmV3U3RhdGUuZGF0YSk7XG5cblx0XHRcdC8vIEFwcGx5XG5cdFx0XHRpZiAoIChuZXdTdGF0ZS50aXRsZSB8fCBkYXRhTm90RW1wdHkpICYmIEhpc3Rvcnkub3B0aW9ucy5kaXNhYmxlU3VpZCAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0Ly8gQWRkIElEIHRvIEhhc2hcblx0XHRcdFx0bmV3U3RhdGUuaGFzaCA9IEhpc3RvcnkuZ2V0U2hvcnRVcmwobmV3U3RhdGUudXJsKS5yZXBsYWNlKC9cXD8/XFwmX3N1aWQuKi8sJycpO1xuXHRcdFx0XHRpZiAoICEvXFw/Ly50ZXN0KG5ld1N0YXRlLmhhc2gpICkge1xuXHRcdFx0XHRcdG5ld1N0YXRlLmhhc2ggKz0gJz8nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld1N0YXRlLmhhc2ggKz0gJyZfc3VpZD0nK25ld1N0YXRlLmlkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIEhhc2hlZCBVUkxcblx0XHRcdG5ld1N0YXRlLmhhc2hlZFVybCA9IEhpc3RvcnkuZ2V0RnVsbFVybChuZXdTdGF0ZS5oYXNoKTtcblxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIFVSTCBpZiB3ZSBoYXZlIGEgZHVwbGljYXRlXG5cdFx0XHRpZiAoIChIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSB8fCBIaXN0b3J5LmJ1Z3Muc2FmYXJpUG9sbCkgJiYgSGlzdG9yeS5oYXNVcmxEdXBsaWNhdGUobmV3U3RhdGUpICkge1xuXHRcdFx0XHRuZXdTdGF0ZS51cmwgPSBuZXdTdGF0ZS5oYXNoZWRVcmw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gbmV3U3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QoZGF0YSx0aXRsZSx1cmwpXG5cdFx0ICogQ3JlYXRlcyBhIG9iamVjdCBiYXNlZCBvbiB0aGUgZGF0YSwgdGl0bGUgYW5kIHVybCBzdGF0ZSBwYXJhbXNcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdCA9IGZ1bmN0aW9uKGRhdGEsdGl0bGUsdXJsKXtcblx0XHRcdC8vIEhhc2hpZnlcblx0XHRcdHZhciBTdGF0ZSA9IHtcblx0XHRcdFx0J2RhdGEnOiBkYXRhLFxuXHRcdFx0XHQndGl0bGUnOiB0aXRsZSxcblx0XHRcdFx0J3VybCc6IHVybFxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gRXhwYW5kIHRoZSBTdGF0ZVxuXHRcdFx0U3RhdGUgPSBIaXN0b3J5Lm5vcm1hbGl6ZVN0YXRlKFN0YXRlKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG9iamVjdFxuXHRcdFx0cmV0dXJuIFN0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldFN0YXRlQnlJZChpZClcblx0XHQgKiBHZXQgYSBzdGF0ZSBieSBpdCdzIFVJRFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0U3RhdGVCeUlkID0gZnVuY3Rpb24oaWQpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0aWQgPSBTdHJpbmcoaWQpO1xuXG5cdFx0XHQvLyBSZXRyaWV2ZVxuXHRcdFx0dmFyIFN0YXRlID0gSGlzdG9yeS5pZFRvU3RhdGVbaWRdIHx8IEhpc3Rvcnkuc3RvcmUuaWRUb1N0YXRlW2lkXSB8fCB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIFJldHVybiBTdGF0ZVxuXHRcdFx0cmV0dXJuIFN0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBHZXQgYSBTdGF0ZSdzIFN0cmluZ1xuXHRcdCAqIEBwYXJhbSB7U3RhdGV9IHBhc3NlZFN0YXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRTdGF0ZVN0cmluZyA9IGZ1bmN0aW9uKHBhc3NlZFN0YXRlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZSwgY2xlYW5lZFN0YXRlLCBzdHI7XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHRTdGF0ZSA9IEhpc3Rvcnkubm9ybWFsaXplU3RhdGUocGFzc2VkU3RhdGUpO1xuXG5cdFx0XHQvLyBDbGVhblxuXHRcdFx0Y2xlYW5lZFN0YXRlID0ge1xuXHRcdFx0XHRkYXRhOiBTdGF0ZS5kYXRhLFxuXHRcdFx0XHR0aXRsZTogcGFzc2VkU3RhdGUudGl0bGUsXG5cdFx0XHRcdHVybDogcGFzc2VkU3RhdGUudXJsXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0c3RyID0gSlNPTi5zdHJpbmdpZnkoY2xlYW5lZFN0YXRlKTtcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBHZXQgYSBTdGF0ZSdzIElEXG5cdFx0ICogQHBhcmFtIHtTdGF0ZX0gcGFzc2VkU3RhdGVcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRTdGF0ZUlkID0gZnVuY3Rpb24ocGFzc2VkU3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlLCBpZDtcblxuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdFN0YXRlID0gSGlzdG9yeS5ub3JtYWxpemVTdGF0ZShwYXNzZWRTdGF0ZSk7XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHRpZCA9IFN0YXRlLmlkO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBpZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShTdGF0ZSlcblx0XHQgKiBDcmVhdGVzIGEgSGFzaCBmb3IgdGhlIFN0YXRlIE9iamVjdFxuXHRcdCAqIEBwYXJhbSB7U3RhdGV9IHBhc3NlZFN0YXRlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBoYXNoXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRIYXNoQnlTdGF0ZSA9IGZ1bmN0aW9uKHBhc3NlZFN0YXRlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZSwgaGFzaDtcblxuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdFN0YXRlID0gSGlzdG9yeS5ub3JtYWxpemVTdGF0ZShwYXNzZWRTdGF0ZSk7XG5cblx0XHRcdC8vIEhhc2hcblx0XHRcdGhhc2ggPSBTdGF0ZS5oYXNoO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmV4dHJhY3RJZCh1cmxfb3JfaGFzaClcblx0XHQgKiBHZXQgYSBTdGF0ZSBJRCBieSBpdCdzIFVSTCBvciBIYXNoXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybF9vcl9oYXNoXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSBpZFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZXh0cmFjdElkID0gZnVuY3Rpb24gKCB1cmxfb3JfaGFzaCApIHtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBpZCxwYXJ0cyx1cmwsIHRtcDtcblxuXHRcdFx0Ly8gRXh0cmFjdFxuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgVVJMIGhhcyBhICMsIHVzZSB0aGUgaWQgZnJvbSBiZWZvcmUgdGhlICNcblx0XHRcdGlmICh1cmxfb3JfaGFzaC5pbmRleE9mKCcjJykgIT0gLTEpXG5cdFx0XHR7XG5cdFx0XHRcdHRtcCA9IHVybF9vcl9oYXNoLnNwbGl0KFwiI1wiKVswXTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dG1wID0gdXJsX29yX2hhc2g7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHBhcnRzID0gLyguKilcXCZfc3VpZD0oWzAtOV0rKSQvLmV4ZWModG1wKTtcblx0XHRcdHVybCA9IHBhcnRzID8gKHBhcnRzWzFdfHx1cmxfb3JfaGFzaCkgOiB1cmxfb3JfaGFzaDtcblx0XHRcdGlkID0gcGFydHMgPyBTdHJpbmcocGFydHNbMl18fCcnKSA6ICcnO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBpZHx8ZmFsc2U7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNUcmFkaXRpb25hbEFuY2hvclxuXHRcdCAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHVybCBpcyBhIHRyYWRpdGlvbmFsIGFuY2hvciBvciBub3Rcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsX29yX2hhc2hcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaXNUcmFkaXRpb25hbEFuY2hvciA9IGZ1bmN0aW9uKHVybF9vcl9oYXNoKXtcblx0XHRcdC8vIENoZWNrXG5cdFx0XHR2YXIgaXNUcmFkaXRpb25hbCA9ICEoL1tcXC9cXD9cXC5dLy50ZXN0KHVybF9vcl9oYXNoKSk7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGlzVHJhZGl0aW9uYWw7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZXh0cmFjdFN0YXRlXG5cdFx0ICogR2V0IGEgU3RhdGUgYnkgaXQncyBVUkwgb3IgSGFzaFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxfb3JfaGFzaFxuXHRcdCAqIEByZXR1cm4ge1N0YXRlfG51bGx9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5leHRyYWN0U3RhdGUgPSBmdW5jdGlvbih1cmxfb3JfaGFzaCxjcmVhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlID0gbnVsbCwgaWQsIHVybDtcblx0XHRcdGNyZWF0ZSA9IGNyZWF0ZXx8ZmFsc2U7XG5cblx0XHRcdC8vIEZldGNoIFNVSURcblx0XHRcdGlkID0gSGlzdG9yeS5leHRyYWN0SWQodXJsX29yX2hhc2gpO1xuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJZChpZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZldGNoIFNVSUQgcmV0dXJuZWQgbm8gU3RhdGVcblx0XHRcdGlmICggIVN0YXRlICkge1xuXHRcdFx0XHQvLyBGZXRjaCBVUkxcblx0XHRcdFx0dXJsID0gSGlzdG9yeS5nZXRGdWxsVXJsKHVybF9vcl9oYXNoKTtcblxuXHRcdFx0XHQvLyBDaGVjayBVUkxcblx0XHRcdFx0aWQgPSBIaXN0b3J5LmdldElkQnlVcmwodXJsKXx8ZmFsc2U7XG5cdFx0XHRcdGlmICggaWQgKSB7XG5cdFx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJZChpZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgU3RhdGVcblx0XHRcdFx0aWYgKCAhU3RhdGUgJiYgY3JlYXRlICYmICFIaXN0b3J5LmlzVHJhZGl0aW9uYWxBbmNob3IodXJsX29yX2hhc2gpICkge1xuXHRcdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdChudWxsLG51bGwsdXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBTdGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRJZEJ5VXJsKClcblx0XHQgKiBHZXQgYSBTdGF0ZSBJRCBieSBhIFN0YXRlIFVSTFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SWRCeVVybCA9IGZ1bmN0aW9uKHVybCl7XG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0dmFyIGlkID0gSGlzdG9yeS51cmxUb0lkW3VybF0gfHwgSGlzdG9yeS5zdG9yZS51cmxUb0lkW3VybF0gfHwgdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBpZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRMYXN0U2F2ZWRTdGF0ZSgpXG5cdFx0ICogR2V0IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhLCB0aXRsZSBhbmQgdXJsIG9mIHRoZSBjdXJyZW50IHN0YXRlXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBTdGF0ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0TGFzdFNhdmVkU3RhdGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIEhpc3Rvcnkuc2F2ZWRTdGF0ZXNbSGlzdG9yeS5zYXZlZFN0YXRlcy5sZW5ndGgtMV18fHVuZGVmaW5lZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRMYXN0U3RvcmVkU3RhdGUoKVxuXHRcdCAqIEdldCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSwgdGl0bGUgYW5kIHVybCBvZiB0aGUgY3VycmVudCBzdGF0ZVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gU3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldExhc3RTdG9yZWRTdGF0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gSGlzdG9yeS5zdG9yZWRTdGF0ZXNbSGlzdG9yeS5zdG9yZWRTdGF0ZXMubGVuZ3RoLTFdfHx1bmRlZmluZWQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaGFzVXJsRHVwbGljYXRlXG5cdFx0ICogQ2hlY2tzIGlmIGEgVXJsIHdpbGwgaGF2ZSBhIHVybCBjb25mbGljdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IGhhc0R1cGxpY2F0ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaGFzVXJsRHVwbGljYXRlID0gZnVuY3Rpb24obmV3U3RhdGUpIHtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBoYXNEdXBsaWNhdGUgPSBmYWxzZSxcblx0XHRcdFx0b2xkU3RhdGU7XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHRvbGRTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKG5ld1N0YXRlLnVybCk7XG5cblx0XHRcdC8vIENoZWNrXG5cdFx0XHRoYXNEdXBsaWNhdGUgPSBvbGRTdGF0ZSAmJiBvbGRTdGF0ZS5pZCAhPT0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGhhc0R1cGxpY2F0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zdG9yZVN0YXRlXG5cdFx0ICogU3RvcmUgYSBTdGF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gbmV3U3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5LnN0b3JlU3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSl7XG5cdFx0XHQvLyBTdG9yZSB0aGUgU3RhdGVcblx0XHRcdEhpc3RvcnkudXJsVG9JZFtuZXdTdGF0ZS51cmxdID0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdC8vIFB1c2ggdGhlIFN0YXRlXG5cdFx0XHRIaXN0b3J5LnN0b3JlZFN0YXRlcy5wdXNoKEhpc3RvcnkuY2xvbmVPYmplY3QobmV3U3RhdGUpKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5ld1N0YXRlXG5cdFx0XHRyZXR1cm4gbmV3U3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSlcblx0XHQgKiBUZXN0cyB0byBzZWUgaWYgdGhlIHN0YXRlIGlzIHRoZSBsYXN0IHN0YXRlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG5ld1N0YXRlXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn0gaXNMYXN0XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pc0xhc3RTYXZlZFN0YXRlID0gZnVuY3Rpb24obmV3U3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIGlzTGFzdCA9IGZhbHNlLFxuXHRcdFx0XHRuZXdJZCwgb2xkU3RhdGUsIG9sZElkO1xuXG5cdFx0XHQvLyBDaGVja1xuXHRcdFx0aWYgKCBIaXN0b3J5LnNhdmVkU3RhdGVzLmxlbmd0aCApIHtcblx0XHRcdFx0bmV3SWQgPSBuZXdTdGF0ZS5pZDtcblx0XHRcdFx0b2xkU3RhdGUgPSBIaXN0b3J5LmdldExhc3RTYXZlZFN0YXRlKCk7XG5cdFx0XHRcdG9sZElkID0gb2xkU3RhdGUuaWQ7XG5cblx0XHRcdFx0Ly8gQ2hlY2tcblx0XHRcdFx0aXNMYXN0ID0gKG5ld0lkID09PSBvbGRJZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGlzTGFzdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zYXZlU3RhdGVcblx0XHQgKiBQdXNoIGEgU3RhdGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbmV3U3RhdGVcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufSBjaGFuZ2VkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYXZlU3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSl7XG5cdFx0XHQvLyBDaGVjayBIYXNoXG5cdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHVzaCB0aGUgU3RhdGVcblx0XHRcdEhpc3Rvcnkuc2F2ZWRTdGF0ZXMucHVzaChIaXN0b3J5LmNsb25lT2JqZWN0KG5ld1N0YXRlKSk7XG5cblx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRTdGF0ZUJ5SW5kZXgoKVxuXHRcdCAqIEdldHMgYSBzdGF0ZSBieSB0aGUgaW5kZXhcblx0XHQgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4XG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0U3RhdGVCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlID0gbnVsbDtcblxuXHRcdFx0Ly8gSGFuZGxlXG5cdFx0XHRpZiAoIHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdC8vIEdldCB0aGUgbGFzdCBpbnNlcnRlZFxuXHRcdFx0XHRTdGF0ZSA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXNbSGlzdG9yeS5zYXZlZFN0YXRlcy5sZW5ndGgtMV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHQvLyBHZXQgZnJvbSB0aGUgZW5kXG5cdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5zYXZlZFN0YXRlc1tIaXN0b3J5LnNhdmVkU3RhdGVzLmxlbmd0aCtpbmRleF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gR2V0IGZyb20gdGhlIGJlZ2lubmluZ1xuXHRcdFx0XHRTdGF0ZSA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXNbaW5kZXhdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gU3RhdGVcblx0XHRcdHJldHVybiBTdGF0ZTtcblx0XHR9O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0Q3VycmVudEluZGV4KClcblx0XHQgKiBHZXRzIHRoZSBjdXJyZW50IGluZGV4XG5cdFx0ICogQHJldHVybiAoaW50ZWdlcilcblx0XHQqL1xuXHRcdEhpc3RvcnkuZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBpbmRleCA9IG51bGw7XG5cdFx0XHRcblx0XHRcdC8vIE5vIHN0YXRlcyBzYXZlZFxuXHRcdFx0aWYoSGlzdG9yeS5zYXZlZFN0YXRlcy5sZW5ndGggPCAxKSB7XG5cdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpbmRleCA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXMubGVuZ3RoLTE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5kZXg7XG5cdFx0fTtcblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gSGFzaCBIZWxwZXJzXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEhhc2goKVxuXHRcdCAqIEBwYXJhbSB7TG9jYXRpb249fSBsb2NhdGlvblxuXHRcdCAqIEdldHMgdGhlIGN1cnJlbnQgZG9jdW1lbnQgaGFzaFxuXHRcdCAqIE5vdGU6IHVubGlrZSBsb2NhdGlvbi5oYXNoLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIHRoZSBlc2NhcGVkIGhhc2ggaW4gYWxsIGJyb3dzZXJzXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SGFzaCA9IGZ1bmN0aW9uKGRvYyl7XG5cdFx0XHR2YXIgdXJsID0gSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoZG9jKSxcblx0XHRcdFx0aGFzaDtcblx0XHRcdGhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVVybCh1cmwpO1xuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkudW5lc2NhcGVIYXNoKClcblx0XHQgKiBub3JtYWxpemUgYW5kIFVuZXNjYXBlIGEgSGFzaFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkudW5lc2NhcGVIYXNoID0gZnVuY3Rpb24oaGFzaCl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgcmVzdWx0ID0gSGlzdG9yeS5ub3JtYWxpemVIYXNoKGhhc2gpO1xuXG5cdFx0XHQvLyBVbmVzY2FwZSBoYXNoXG5cdFx0XHRyZXN1bHQgPSBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcblxuXHRcdFx0Ly8gUmV0dXJuIHJlc3VsdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5ub3JtYWxpemVIYXNoKClcblx0XHQgKiBub3JtYWxpemUgYSBoYXNoIGFjcm9zcyBicm93c2Vyc1xuXHRcdCAqIEByZXR1cm4ge3N0cmluZ31cblx0XHQgKi9cblx0XHRIaXN0b3J5Lm5vcm1hbGl6ZUhhc2ggPSBmdW5jdGlvbihoYXNoKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciByZXN1bHQgPSBoYXNoLnJlcGxhY2UoL1teI10qIy8sJycpLnJlcGxhY2UoLyMuKi8sICcnKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHJlc3VsdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zZXRIYXNoKGhhc2gpXG5cdFx0ICogU2V0cyB0aGUgZG9jdW1lbnQgaGFzaFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LnNldEhhc2ggPSBmdW5jdGlvbihoYXNoLHF1ZXVlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZSwgcGFnZVVybDtcblxuXHRcdFx0Ly8gSGFuZGxlIFF1ZXVlaW5nXG5cdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnNldEhhc2g6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRzY29wZTogSGlzdG9yeSxcblx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5zZXRIYXNoLFxuXHRcdFx0XHRcdGFyZ3M6IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9nXG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkuc2V0SGFzaDogY2FsbGVkJyxoYXNoKTtcblxuXHRcdFx0Ly8gTWFrZSBCdXN5ICsgQ29udGludWVcblx0XHRcdEhpc3RvcnkuYnVzeSh0cnVlKTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgaGFzaCBpcyBhIHN0YXRlXG5cdFx0XHRTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKGhhc2gsdHJ1ZSk7XG5cdFx0XHRpZiAoIFN0YXRlICYmICFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdFx0Ly8gSGFzaCBpcyBhIHN0YXRlIHNvIHNraXAgdGhlIHNldEhhc2hcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnNldEhhc2g6IEhhc2ggaXMgYSBzdGF0ZSBzbyBza2lwcGluZyB0aGUgaGFzaCBzZXQgd2l0aCBhIGRpcmVjdCBwdXNoU3RhdGUgY2FsbCcsYXJndW1lbnRzKTtcblxuXHRcdFx0XHQvLyBQdXNoU3RhdGVcblx0XHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUoU3RhdGUuZGF0YSxTdGF0ZS50aXRsZSxTdGF0ZS51cmwsZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIEhpc3RvcnkuZ2V0SGFzaCgpICE9PSBoYXNoICkge1xuXHRcdFx0XHQvLyBIYXNoIGlzIGEgcHJvcGVyIGhhc2gsIHNvIGFwcGx5IGl0XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGJyb3dzZXIgYnVnc1xuXHRcdFx0XHRpZiAoIEhpc3RvcnkuYnVncy5zZXRIYXNoICkge1xuXHRcdFx0XHRcdC8vIEZpeCBTYWZhcmkgQnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD01NjI0OVxuXG5cdFx0XHRcdFx0Ly8gRmV0Y2ggdGhlIGJhc2UgcGFnZVxuXHRcdFx0XHRcdHBhZ2VVcmwgPSBIaXN0b3J5LmdldFBhZ2VVcmwoKTtcblxuXHRcdFx0XHRcdC8vIFNhZmFyaSBoYXNoIGFwcGx5XG5cdFx0XHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUobnVsbCxudWxsLHBhZ2VVcmwrJyMnK2hhc2gsZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIE5vcm1hbCBoYXNoIGFwcGx5XG5cdFx0XHRcdFx0ZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IGhhc2g7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmVzY2FwZSgpXG5cdFx0ICogbm9ybWFsaXplIGFuZCBFc2NhcGUgYSBIYXNoXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZXNjYXBlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIHJlc3VsdCA9IEhpc3Rvcnkubm9ybWFsaXplSGFzaChoYXNoKTtcblxuXHRcdFx0Ly8gRXNjYXBlIGhhc2hcblx0XHRcdHJlc3VsdCA9IHdpbmRvdy5lbmNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcblxuXHRcdFx0Ly8gSUU2IEVzY2FwZSBCdWdcblx0XHRcdGlmICggIUhpc3RvcnkuYnVncy5oYXNoRXNjYXBlICkge1xuXHRcdFx0XHQvLyBSZXN0b3JlIGNvbW1vbiBwYXJ0c1xuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHRcblx0XHRcdFx0XHQucmVwbGFjZSgvXFwlMjEvZywnIScpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcJTI2L2csJyYnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXCUzRC9nLCc9Jylcblx0XHRcdFx0XHQucmVwbGFjZSgvXFwlM0YvZywnPycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gcmVzdWx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEhhc2hCeVVybCh1cmwpXG5cdFx0ICogRXh0cmFjdHMgdGhlIEhhc2ggZnJvbSBhIFVSTFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SGFzaEJ5VXJsID0gZnVuY3Rpb24odXJsKXtcblx0XHRcdC8vIEV4dHJhY3QgdGhlIGhhc2hcblx0XHRcdHZhciBoYXNoID0gU3RyaW5nKHVybClcblx0XHRcdFx0LnJlcGxhY2UoLyhbXiNdKikjPyhbXiNdKikjPyguKikvLCAnJDInKVxuXHRcdFx0XHQ7XG5cblx0XHRcdC8vIFVuZXNjYXBlIGhhc2hcblx0XHRcdGhhc2ggPSBIaXN0b3J5LnVuZXNjYXBlSGFzaChoYXNoKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGhhc2hcblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNldFRpdGxlKHRpdGxlKVxuXHRcdCAqIEFwcGxpZXMgdGhlIHRpdGxlIHRvIHRoZSBkb2N1bWVudFxuXHRcdCAqIEBwYXJhbSB7U3RhdGV9IG5ld1N0YXRlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRIaXN0b3J5LnNldFRpdGxlID0gZnVuY3Rpb24obmV3U3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIHRpdGxlID0gbmV3U3RhdGUudGl0bGUsXG5cdFx0XHRcdGZpcnN0U3RhdGU7XG5cblx0XHRcdC8vIEluaXRpYWxcblx0XHRcdGlmICggIXRpdGxlICkge1xuXHRcdFx0XHRmaXJzdFN0YXRlID0gSGlzdG9yeS5nZXRTdGF0ZUJ5SW5kZXgoMCk7XG5cdFx0XHRcdGlmICggZmlyc3RTdGF0ZSAmJiBmaXJzdFN0YXRlLnVybCA9PT0gbmV3U3RhdGUudXJsICkge1xuXHRcdFx0XHRcdHRpdGxlID0gZmlyc3RTdGF0ZS50aXRsZXx8SGlzdG9yeS5vcHRpb25zLmluaXRpYWxUaXRsZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RpdGxlJylbMF0uaW5uZXJIVE1MID0gdGl0bGUucmVwbGFjZSgnPCcsJyZsdDsnKS5yZXBsYWNlKCc+JywnJmd0OycpLnJlcGxhY2UoJyAmICcsJyAmYW1wOyAnKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoICggRXhjZXB0aW9uICkgeyB9XG5cdFx0XHRkb2N1bWVudC50aXRsZSA9IHRpdGxlO1xuXG5cdFx0XHQvLyBDaGFpblxuXHRcdFx0cmV0dXJuIEhpc3Rvcnk7XG5cdFx0fTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBRdWV1ZWluZ1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5xdWV1ZXNcblx0XHQgKiBUaGUgbGlzdCBvZiBxdWV1ZXMgdG8gdXNlXG5cdFx0ICogRmlyc3QgSW4sIEZpcnN0IE91dFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkucXVldWVzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmJ1c3kodmFsdWUpXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBbb3B0aW9uYWxdXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn0gYnVzeVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuYnVzeSA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdC8vIEFwcGx5XG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5idXN5OiBjaGFuZ2luZyBbJysoSGlzdG9yeS5idXN5LmZsYWd8fGZhbHNlKSsnXSB0byBbJysodmFsdWV8fGZhbHNlKSsnXScsIEhpc3RvcnkucXVldWVzLmxlbmd0aCk7XG5cdFx0XHRcdEhpc3RvcnkuYnVzeS5mbGFnID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBEZWZhdWx0XG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIEhpc3RvcnkuYnVzeS5mbGFnID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0SGlzdG9yeS5idXN5LmZsYWcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUXVldWVcblx0XHRcdGlmICggIUhpc3RvcnkuYnVzeS5mbGFnICkge1xuXHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIHF1ZXVlXG5cdFx0XHRcdGNsZWFyVGltZW91dChIaXN0b3J5LmJ1c3kudGltZW91dCk7XG5cdFx0XHRcdHZhciBmaXJlTmV4dCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dmFyIGksIHF1ZXVlLCBpdGVtO1xuXHRcdFx0XHRcdGlmICggSGlzdG9yeS5idXN5LmZsYWcgKSByZXR1cm47XG5cdFx0XHRcdFx0Zm9yICggaT1IaXN0b3J5LnF1ZXVlcy5sZW5ndGgtMTsgaSA+PSAwOyAtLWkgKSB7XG5cdFx0XHRcdFx0XHRxdWV1ZSA9IEhpc3RvcnkucXVldWVzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCBxdWV1ZS5sZW5ndGggPT09IDAgKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdGl0ZW0gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5maXJlUXVldWVJdGVtKGl0ZW0pO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5idXN5LnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZpcmVOZXh0LEhpc3Rvcnkub3B0aW9ucy5idXN5RGVsYXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0SGlzdG9yeS5idXN5LnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZpcmVOZXh0LEhpc3Rvcnkub3B0aW9ucy5idXN5RGVsYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBIaXN0b3J5LmJ1c3kuZmxhZztcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5idXN5LmZsYWdcblx0XHQgKi9cblx0XHRIaXN0b3J5LmJ1c3kuZmxhZyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5maXJlUXVldWVJdGVtKGl0ZW0pXG5cdFx0ICogRmlyZSBhIFF1ZXVlIEl0ZW1cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHRcdCAqIEByZXR1cm4ge01peGVkfSByZXN1bHRcblx0XHQgKi9cblx0XHRIaXN0b3J5LmZpcmVRdWV1ZUl0ZW0gPSBmdW5jdGlvbihpdGVtKXtcblx0XHRcdHJldHVybiBpdGVtLmNhbGxiYWNrLmFwcGx5KGl0ZW0uc2NvcGV8fEhpc3RvcnksaXRlbS5hcmdzfHxbXSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkucHVzaFF1ZXVlKGNhbGxiYWNrLGFyZ3MpXG5cdFx0ICogQWRkIGFuIGl0ZW0gdG8gdGhlIHF1ZXVlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gW3Njb3BlLGNhbGxiYWNrLGFyZ3MscXVldWVdXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5wdXNoUXVldWUgPSBmdW5jdGlvbihpdGVtKXtcblx0XHRcdC8vIFByZXBhcmUgdGhlIHF1ZXVlXG5cdFx0XHRIaXN0b3J5LnF1ZXVlc1tpdGVtLnF1ZXVlfHwwXSA9IEhpc3RvcnkucXVldWVzW2l0ZW0ucXVldWV8fDBdfHxbXTtcblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBxdWV1ZVxuXHRcdFx0SGlzdG9yeS5xdWV1ZXNbaXRlbS5xdWV1ZXx8MF0ucHVzaChpdGVtKTtcblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnF1ZXVlIChpdGVtLHF1ZXVlKSwgKGZ1bmMscXVldWUpLCAoZnVuYyksIChpdGVtKVxuXHRcdCAqIEVpdGhlciBmaXJzIHRoZSBpdGVtIG5vdyBpZiBub3QgYnVzeSwgb3IgYWRkcyBpdCB0byB0aGUgcXVldWVcblx0XHQgKi9cblx0XHRIaXN0b3J5LnF1ZXVlID0gZnVuY3Rpb24oaXRlbSxxdWV1ZSl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRpdGVtID0ge1xuXHRcdFx0XHRcdGNhbGxiYWNrOiBpdGVtXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBxdWV1ZSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdGl0ZW0ucXVldWUgPSBxdWV1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlXG5cdFx0XHRpZiAoIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHRIaXN0b3J5LnB1c2hRdWV1ZShpdGVtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdEhpc3RvcnkuZmlyZVF1ZXVlSXRlbShpdGVtKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmNsZWFyUXVldWUoKVxuXHRcdCAqIENsZWFycyB0aGUgUXVldWVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmNsZWFyUXVldWUgPSBmdW5jdGlvbigpe1xuXHRcdFx0SGlzdG9yeS5idXN5LmZsYWcgPSBmYWxzZTtcblx0XHRcdEhpc3RvcnkucXVldWVzID0gW107XG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIElFIEJ1ZyBGaXhcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc3RhdGVDaGFuZ2VkXG5cdFx0ICogU3RhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBzdGF0ZSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBkb3VibGUgY2hlY2sgd2FzIGluaXRpYWxpc2VkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zdGF0ZUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZG91YmxlQ2hlY2tlclxuXHRcdCAqIENvbnRhaW5zIHRoZSB0aW1lb3V0IHVzZWQgZm9yIHRoZSBkb3VibGUgY2hlY2tzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5kb3VibGVDaGVja2VyID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRvdWJsZUNoZWNrQ29tcGxldGUoKVxuXHRcdCAqIENvbXBsZXRlIGEgZG91YmxlIGNoZWNrXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gVXBkYXRlXG5cdFx0XHRIaXN0b3J5LnN0YXRlQ2hhbmdlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyXG5cdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIoKTtcblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIoKVxuXHRcdCAqIENsZWFyIGEgZG91YmxlIGNoZWNrXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ2xlYXJcblx0XHRcdGlmICggSGlzdG9yeS5kb3VibGVDaGVja2VyICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoSGlzdG9yeS5kb3VibGVDaGVja2VyKTtcblx0XHRcdFx0SGlzdG9yeS5kb3VibGVDaGVja2VyID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kb3VibGVDaGVjaygpXG5cdFx0ICogQ3JlYXRlIGEgZG91YmxlIGNoZWNrXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrID0gZnVuY3Rpb24odHJ5QWdhaW4pe1xuXHRcdFx0Ly8gUmVzZXRcblx0XHRcdEhpc3Rvcnkuc3RhdGVDaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIoKTtcblxuXHRcdFx0Ly8gRml4IElFNixJRTcgYnVnIHdoZXJlIGNhbGxpbmcgaGlzdG9yeS5iYWNrIG9yIGhpc3RvcnkuZm9yd2FyZCBkb2VzIG5vdCBhY3R1YWxseSBjaGFuZ2UgdGhlIGhhc2ggKHdoZXJlYXMgZG9pbmcgaXQgbWFudWFsbHkgZG9lcylcblx0XHRcdC8vIEZpeCBTYWZhcmkgNSBidWcgd2hlcmUgc29tZXRpbWVzIHRoZSBzdGF0ZSBkb2VzIG5vdCBjaGFuZ2U6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD00Mjk0MFxuXHRcdFx0aWYgKCBIaXN0b3J5LmJ1Z3MuaWVEb3VibGVDaGVjayApIHtcblx0XHRcdFx0Ly8gQXBwbHkgQ2hlY2tcblx0XHRcdFx0SGlzdG9yeS5kb3VibGVDaGVja2VyID0gc2V0VGltZW91dChcblx0XHRcdFx0XHRmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5kb3VibGVDaGVja0NsZWFyKCk7XG5cdFx0XHRcdFx0XHRpZiAoICFIaXN0b3J5LnN0YXRlQ2hhbmdlZCApIHtcblx0XHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmRvdWJsZUNoZWNrOiBTdGF0ZSBoYXMgbm90IHlldCBjaGFuZ2VkLCB0cnlpbmcgYWdhaW4nLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1BdHRlbXB0XG5cdFx0XHRcdFx0XHRcdHRyeUFnYWluKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEhpc3Rvcnkub3B0aW9ucy5kb3VibGVDaGVja0ludGVydmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFNhZmFyaSBCdWcgRml4XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNhZmFyaVN0YXRlUG9sbCgpXG5cdFx0ICogUG9sbCB0aGUgY3VycmVudCBzdGF0ZVxuXHRcdCAqIEByZXR1cm4ge0hpc3Rvcnl9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYWZhcmlTdGF0ZVBvbGwgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gUG9sbCB0aGUgVVJMXG5cblx0XHRcdC8vIEdldCB0aGUgTGFzdCBTdGF0ZSB3aGljaCBoYXMgdGhlIG5ldyBVUkxcblx0XHRcdHZhclxuXHRcdFx0XHR1cmxTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpLFxuXHRcdFx0XHRuZXdTdGF0ZTtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGEgZGlmZmVyZW5jZVxuXHRcdFx0aWYgKCAhSGlzdG9yeS5pc0xhc3RTYXZlZFN0YXRlKHVybFN0YXRlKSApIHtcblx0XHRcdFx0bmV3U3RhdGUgPSB1cmxTdGF0ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIHdlIGhhdmUgYSBzdGF0ZSB3aXRoIHRoYXQgdXJsXG5cdFx0XHQvLyBJZiBub3QgY3JlYXRlIGl0XG5cdFx0XHRpZiAoICFuZXdTdGF0ZSApIHtcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnNhZmFyaVN0YXRlUG9sbDogbmV3Jyk7XG5cdFx0XHRcdG5ld1N0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSB0aGUgTmV3IFN0YXRlXG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkuc2FmYXJpU3RhdGVQb2xsOiB0cmlnZ2VyJyk7XG5cdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ3BvcHN0YXRlJyk7XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFN0YXRlIEFsaWFzZXNcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuYmFjayhxdWV1ZSlcblx0XHQgKiBTZW5kIHRoZSBicm93c2VyIGhpc3RvcnkgYmFjayBvbmUgaXRlbVxuXHRcdCAqIEBwYXJhbSB7SW50ZWdlcn0gcXVldWUgW29wdGlvbmFsXVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuYmFjayA9IGZ1bmN0aW9uKHF1ZXVlKXtcblx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5iYWNrOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBIYW5kbGUgUXVldWVpbmdcblx0XHRcdGlmICggcXVldWUgIT09IGZhbHNlICYmIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuYmFjazogd2UgbXVzdCB3YWl0JywgYXJndW1lbnRzKTtcblx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdHNjb3BlOiBIaXN0b3J5LFxuXHRcdFx0XHRcdGNhbGxiYWNrOiBIaXN0b3J5LmJhY2ssXG5cdFx0XHRcdFx0YXJnczogYXJndW1lbnRzLFxuXHRcdFx0XHRcdHF1ZXVlOiBxdWV1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIEJ1c3kgKyBDb250aW51ZVxuXHRcdFx0SGlzdG9yeS5idXN5KHRydWUpO1xuXG5cdFx0XHQvLyBGaXggY2VydGFpbiBicm93c2VyIGJ1Z3MgdGhhdCBwcmV2ZW50IHRoZSBzdGF0ZSBmcm9tIGNoYW5naW5nXG5cdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdEhpc3RvcnkuYmFjayhmYWxzZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gR28gYmFja1xuXHRcdFx0aGlzdG9yeS5nbygtMSk7XG5cblx0XHRcdC8vIEVuZCBiYWNrIGNsb3N1cmVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmZvcndhcmQocXVldWUpXG5cdFx0ICogU2VuZCB0aGUgYnJvd3NlciBoaXN0b3J5IGZvcndhcmQgb25lIGl0ZW1cblx0XHQgKiBAcGFyYW0ge0ludGVnZXJ9IHF1ZXVlIFtvcHRpb25hbF1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmZvcndhcmQgPSBmdW5jdGlvbihxdWV1ZSl7XG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuZm9yd2FyZDogY2FsbGVkJywgYXJndW1lbnRzKTtcblxuXHRcdFx0Ly8gSGFuZGxlIFF1ZXVlaW5nXG5cdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmZvcndhcmQ6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRzY29wZTogSGlzdG9yeSxcblx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5mb3J3YXJkLFxuXHRcdFx0XHRcdGFyZ3M6IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBCdXN5ICsgQ29udGludWVcblx0XHRcdEhpc3RvcnkuYnVzeSh0cnVlKTtcblxuXHRcdFx0Ly8gRml4IGNlcnRhaW4gYnJvd3NlciBidWdzIHRoYXQgcHJldmVudCB0aGUgc3RhdGUgZnJvbSBjaGFuZ2luZ1xuXHRcdFx0SGlzdG9yeS5kb3VibGVDaGVjayhmdW5jdGlvbigpe1xuXHRcdFx0XHRIaXN0b3J5LmZvcndhcmQoZmFsc2UpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEdvIGZvcndhcmRcblx0XHRcdGhpc3RvcnkuZ28oMSk7XG5cblx0XHRcdC8vIEVuZCBmb3J3YXJkIGNsb3N1cmVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdvKGluZGV4LHF1ZXVlKVxuXHRcdCAqIFNlbmQgdGhlIGJyb3dzZXIgaGlzdG9yeSBiYWNrIG9yIGZvcndhcmQgaW5kZXggdGltZXNcblx0XHQgKiBAcGFyYW0ge0ludGVnZXJ9IHF1ZXVlIFtvcHRpb25hbF1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmdvID0gZnVuY3Rpb24oaW5kZXgscXVldWUpe1xuXHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmdvOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0Ly8gSGFuZGxlXG5cdFx0XHRpZiAoIGluZGV4ID4gMCApIHtcblx0XHRcdFx0Ly8gRm9yd2FyZFxuXHRcdFx0XHRmb3IgKCBpPTE7IGk8PWluZGV4OyArK2kgKSB7XG5cdFx0XHRcdFx0SGlzdG9yeS5mb3J3YXJkKHF1ZXVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0Ly8gQmFja3dhcmRcblx0XHRcdFx0Zm9yICggaT0tMTsgaT49aW5kZXg7IC0taSApIHtcblx0XHRcdFx0XHRIaXN0b3J5LmJhY2socXVldWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmdvOiBIaXN0b3J5LmdvIHJlcXVpcmVzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBwYXNzZWQuJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEhUTUw1IFN0YXRlIFN1cHBvcnRcblxuXHRcdC8vIE5vbi1OYXRpdmUgcHVzaFN0YXRlIEltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdC8qXG5cdFx0XHQgKiBQcm92aWRlIFNrZWxldG9uIGZvciBIVE1MNCBCcm93c2Vyc1xuXHRcdFx0ICovXG5cblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24oKXt9O1xuXHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUgPSBIaXN0b3J5LnB1c2hTdGF0ZXx8ZW1wdHlGdW5jdGlvbjtcblx0XHRcdEhpc3RvcnkucmVwbGFjZVN0YXRlID0gSGlzdG9yeS5yZXBsYWNlU3RhdGV8fGVtcHR5RnVuY3Rpb247XG5cdFx0fSAvLyBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZVxuXG5cdFx0Ly8gTmF0aXZlIHB1c2hTdGF0ZSBJbXBsZW1lbnRhdGlvblxuXHRcdGVsc2Uge1xuXHRcdFx0Lypcblx0XHRcdCAqIFVzZSBuYXRpdmUgSFRNTDUgSGlzdG9yeSBBUEkgSW1wbGVtZW50YXRpb25cblx0XHRcdCAqL1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3Rvcnkub25Qb3BTdGF0ZShldmVudCxleHRyYSlcblx0XHRcdCAqIFJlZnJlc2ggdGhlIEN1cnJlbnQgU3RhdGVcblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5vblBvcFN0YXRlID0gZnVuY3Rpb24oZXZlbnQsZXh0cmEpe1xuXHRcdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRcdHZhciBzdGF0ZUlkID0gZmFsc2UsIG5ld1N0YXRlID0gZmFsc2UsIGN1cnJlbnRIYXNoLCBjdXJyZW50U3RhdGU7XG5cblx0XHRcdFx0Ly8gUmVzZXQgdGhlIGRvdWJsZSBjaGVja1xuXHRcdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBjdXJyZW50UGF0aCA9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHZhciBuZXdQYXRoID0gSGlzdG9yeS5nZXRTaG9ydFVybChIaXN0b3J5LmdldFN0YXRlKCkuY2xlYW5VcmwpO1xuXG5cdFx0XHRcdC8vIENoZWNrIGZvciBhIEhhc2gsIGFuZCBoYW5kbGUgYXBwb3JpYXRseVxuXHRcdFx0XHRjdXJyZW50SGFzaCA9IEhpc3RvcnkuZ2V0SGFzaCgpO1xuXHRcdFx0XHQgaWYgKCBjdXJyZW50SGFzaCAmJiBjdXJyZW50UGF0aCA9PT0gbmV3UGF0aCApIHtcblx0XHRcdFx0XHQvLyBFeHBhbmQgSGFzaFxuXHRcdFx0XHRcdGN1cnJlbnRTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKGN1cnJlbnRIYXNofHxIaXN0b3J5LmdldExvY2F0aW9uSHJlZigpLHRydWUpO1xuXHRcdFx0XHRcdGlmICggY3VycmVudFN0YXRlICkge1xuXHRcdFx0XHRcdFx0Ly8gV2Ugd2VyZSBhYmxlIHRvIHBhcnNlIGl0LCBpdCBtdXN0IGJlIGEgU3RhdGUhXG5cdFx0XHRcdFx0XHQvLyBMZXQncyBmb3J3YXJkIHRvIHJlcGxhY2VTdGF0ZVxuXHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uUG9wU3RhdGU6IHN0YXRlIGFuY2hvcicsIGN1cnJlbnRIYXNoLCBjdXJyZW50U3RhdGUpO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLmRhdGEsIGN1cnJlbnRTdGF0ZS50aXRsZSwgY3VycmVudFN0YXRlLnVybCwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFRyYWRpdGlvbmFsIEFuY2hvclxuXHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uUG9wU3RhdGU6IHRyYWRpdGlvbmFsIGFuY2hvcicsIGN1cnJlbnRIYXNoKTtcblx0XHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnYW5jaG9yY2hhbmdlJyk7XG5cdFx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFdlIGRvbid0IGNhcmUgZm9yIGhhc2hlc1xuXHRcdFx0XHRcdEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkID0gZmFsc2U7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRW5zdXJlXG5cdFx0XHRcdHN0YXRlSWQgPSBIaXN0b3J5LkFkYXB0ZXIuZXh0cmFjdEV2ZW50RGF0YSgnc3RhdGUnLGV2ZW50LGV4dHJhKSB8fCBmYWxzZTtcblxuXHRcdFx0XHQvLyBGZXRjaCBTdGF0ZVxuXHRcdFx0XHRpZiAoIHN0YXRlSWQgKSB7XG5cdFx0XHRcdFx0Ly8gVmFuaWxsYTogQmFjay9mb3J3YXJkIGJ1dHRvbiB3YXMgdXNlZFxuXHRcdFx0XHRcdG5ld1N0YXRlID0gSGlzdG9yeS5nZXRTdGF0ZUJ5SWQoc3RhdGVJZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkICkge1xuXHRcdFx0XHRcdC8vIFZhbmlsbGE6IEEgbmV3IHN0YXRlIHdhcyBwdXNoZWQsIGFuZCBwb3BzdGF0ZSB3YXMgY2FsbGVkIG1hbnVhbGx5XG5cdFx0XHRcdFx0bmV3U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJZChIaXN0b3J5LmV4cGVjdGVkU3RhdGVJZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSW5pdGlhbCBTdGF0ZVxuXHRcdFx0XHRcdG5ld1N0YXRlID0gSGlzdG9yeS5leHRyYWN0U3RhdGUoSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgU3RhdGUgZGlkIG5vdCBleGlzdCBpbiBvdXIgc3RvcmVcblx0XHRcdFx0aWYgKCAhbmV3U3RhdGUgKSB7XG5cdFx0XHRcdFx0Ly8gUmVnZW5lcmF0ZSB0aGUgU3RhdGVcblx0XHRcdFx0XHRuZXdTdGF0ZSA9IEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QobnVsbCxudWxsLEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2xlYW5cblx0XHRcdFx0SGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgdGhlIHNhbWUgc3RhdGVcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmlzTGFzdFNhdmVkU3RhdGUobmV3U3RhdGUpICkge1xuXHRcdFx0XHRcdC8vIFRoZXJlIGhhcyBiZWVuIG5vIGNoYW5nZSAoanVzdCB0aGUgcGFnZSdzIGhhc2ggaGFzIGZpbmFsbHkgcHJvcGFnYXRlZClcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25Qb3BTdGF0ZTogbm8gY2hhbmdlJywgbmV3U3RhdGUsIEhpc3Rvcnkuc2F2ZWRTdGF0ZXMpO1xuXHRcdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3RvcmUgdGhlIFN0YXRlXG5cdFx0XHRcdEhpc3Rvcnkuc3RvcmVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0XHRcdEhpc3Rvcnkuc2F2ZVN0YXRlKG5ld1N0YXRlKTtcblxuXHRcdFx0XHQvLyBGb3JjZSB1cGRhdGUgb2YgdGhlIHRpdGxlXG5cdFx0XHRcdEhpc3Rvcnkuc2V0VGl0bGUobmV3U3RhdGUpO1xuXG5cdFx0XHRcdC8vIEZpcmUgT3VyIEV2ZW50XG5cdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnc3RhdGVjaGFuZ2UnKTtcblx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblxuXHRcdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHRIaXN0b3J5LkFkYXB0ZXIuYmluZCh3aW5kb3csJ3BvcHN0YXRlJyxIaXN0b3J5Lm9uUG9wU3RhdGUpO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3RvcnkucHVzaFN0YXRlKGRhdGEsdGl0bGUsdXJsKVxuXHRcdFx0ICogQWRkIGEgbmV3IFN0YXRlIHRvIHRoZSBoaXN0b3J5IG9iamVjdCwgYmVjb21lIGl0LCBhbmQgdHJpZ2dlciBvbnBvcHN0YXRlXG5cdFx0XHQgKiBXZSBoYXZlIHRvIHRyaWdnZXIgZm9yIEhUTUw0IGNvbXBhdGliaWxpdHlcblx0XHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHRcdCAqIEByZXR1cm4ge3RydWV9XG5cdFx0XHQgKi9cblx0XHRcdEhpc3RvcnkucHVzaFN0YXRlID0gZnVuY3Rpb24oZGF0YSx0aXRsZSx1cmwscXVldWUpe1xuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucHVzaFN0YXRlOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRcdC8vIENoZWNrIHRoZSBTdGF0ZVxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuZ2V0SGFzaEJ5VXJsKHVybCkgJiYgSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGUgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmpzIGRvZXMgbm90IHN1cHBvcnQgc3RhdGVzIHdpdGggZnJhZ2VtZW50LWlkZW50aWZpZXJzIChoYXNoZXMvYW5jaG9ycykuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgUXVldWVpbmdcblx0XHRcdFx0aWYgKCBxdWV1ZSAhPT0gZmFsc2UgJiYgSGlzdG9yeS5idXN5KCkgKSB7XG5cdFx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucHVzaFN0YXRlOiB3ZSBtdXN0IHdhaXQnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRcdHNjb3BlOiBIaXN0b3J5LFxuXHRcdFx0XHRcdFx0Y2FsbGJhY2s6IEhpc3RvcnkucHVzaFN0YXRlLFxuXHRcdFx0XHRcdFx0YXJnczogYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0cXVldWU6IHF1ZXVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFrZSBCdXN5ICsgQ29udGludWVcblx0XHRcdFx0SGlzdG9yeS5idXN5KHRydWUpO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgbmV3U3RhdGVcblx0XHRcdFx0dmFyIG5ld1N0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdChkYXRhLHRpdGxlLHVybCk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaXRcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmlzTGFzdFNhdmVkU3RhdGUobmV3U3RhdGUpICkge1xuXHRcdFx0XHRcdC8vIFdvbid0IGJlIGEgY2hhbmdlXG5cdFx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgbmV3U3RhdGVcblx0XHRcdFx0XHRIaXN0b3J5LnN0b3JlU3RhdGUobmV3U3RhdGUpO1xuXHRcdFx0XHRcdEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkID0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdFx0XHQvLyBQdXNoIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHRcdGhpc3RvcnkucHVzaFN0YXRlKG5ld1N0YXRlLmlkLG5ld1N0YXRlLnRpdGxlLG5ld1N0YXRlLnVybCk7XG5cblx0XHRcdFx0XHQvLyBGaXJlIEhUTUw1IEV2ZW50XG5cdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdwb3BzdGF0ZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRW5kIHB1c2hTdGF0ZSBjbG9zdXJlXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBIaXN0b3J5LnJlcGxhY2VTdGF0ZShkYXRhLHRpdGxlLHVybClcblx0XHRcdCAqIFJlcGxhY2UgdGhlIFN0YXRlIGFuZCB0cmlnZ2VyIG9ucG9wc3RhdGVcblx0XHRcdCAqIFdlIGhhdmUgdG8gdHJpZ2dlciBmb3IgSFRNTDQgY29tcGF0aWJpbGl0eVxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdFx0ICogQHJldHVybiB7dHJ1ZX1cblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbihkYXRhLHRpdGxlLHVybCxxdWV1ZSl7XG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5yZXBsYWNlU3RhdGU6IGNhbGxlZCcsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgdGhlIFN0YXRlXG5cdFx0XHRcdGlmICggSGlzdG9yeS5nZXRIYXNoQnlVcmwodXJsKSAmJiBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuanMgZG9lcyBub3Qgc3VwcG9ydCBzdGF0ZXMgd2l0aCBmcmFnZW1lbnQtaWRlbnRpZmllcnMgKGhhc2hlcy9hbmNob3JzKS4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBRdWV1ZWluZ1xuXHRcdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5yZXBsYWNlU3RhdGU6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdFx0c2NvcGU6IEhpc3RvcnksXG5cdFx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5yZXBsYWNlU3RhdGUsXG5cdFx0XHRcdFx0XHRhcmdzOiBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIEJ1c3kgKyBDb250aW51ZVxuXHRcdFx0XHRIaXN0b3J5LmJ1c3kodHJ1ZSk7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHR2YXIgbmV3U3RhdGUgPSBIaXN0b3J5LmNyZWF0ZVN0YXRlT2JqZWN0KGRhdGEsdGl0bGUsdXJsKTtcblxuXHRcdFx0XHQvLyBDaGVjayBpdFxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSkgKSB7XG5cdFx0XHRcdFx0Ly8gV29uJ3QgYmUgYSBjaGFuZ2Vcblx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHRcdEhpc3Rvcnkuc3RvcmVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0XHRcdFx0SGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPSBuZXdTdGF0ZS5pZDtcblxuXHRcdFx0XHRcdC8vIFB1c2ggdGhlIG5ld1N0YXRlXG5cdFx0XHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUobmV3U3RhdGUuaWQsbmV3U3RhdGUudGl0bGUsbmV3U3RhdGUudXJsKTtcblxuXHRcdFx0XHRcdC8vIEZpcmUgSFRNTDUgRXZlbnRcblx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ3BvcHN0YXRlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFbmQgcmVwbGFjZVN0YXRlIGNsb3N1cmVcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXG5cdFx0fSAvLyAhSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGVcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBJbml0aWFsaXNlXG5cblx0XHQvKipcblx0XHQgKiBMb2FkIHRoZSBTdG9yZVxuXHRcdCAqL1xuXHRcdGlmICggc2Vzc2lvblN0b3JhZ2UgKSB7XG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0SGlzdG9yeS5zdG9yZSA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnSGlzdG9yeS5zdG9yZScpKXx8e307XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0SGlzdG9yeS5zdG9yZSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOb3JtYWxpemVcblx0XHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBEZWZhdWx0IExvYWRcblx0XHRcdEhpc3Rvcnkuc3RvcmUgPSB7fTtcblx0XHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUoKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDbGVhciBJbnRlcnZhbHMgb24gZXhpdCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdCAqL1xuXHRcdEhpc3RvcnkuQWRhcHRlci5iaW5kKHdpbmRvdyxcInVubG9hZFwiLEhpc3RvcnkuY2xlYXJBbGxJbnRlcnZhbHMpO1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIHRoZSBpbml0aWFsIFN0YXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYXZlU3RhdGUoSGlzdG9yeS5zdG9yZVN0YXRlKEhpc3RvcnkuZXh0cmFjdFN0YXRlKEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCksdHJ1ZSkpKTtcblxuXHRcdC8qKlxuXHRcdCAqIEJpbmQgZm9yIFNhdmluZyBTdG9yZVxuXHRcdCAqL1xuXHRcdGlmICggc2Vzc2lvblN0b3JhZ2UgKSB7XG5cdFx0XHQvLyBXaGVuIHRoZSBwYWdlIGlzIGNsb3NlZFxuXHRcdFx0SGlzdG9yeS5vblVubG9hZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vIFByZXBhcmVcblx0XHRcdFx0dmFyXHRjdXJyZW50U3RvcmUsIGl0ZW0sIGN1cnJlbnRTdG9yZVN0cmluZztcblxuXHRcdFx0XHQvLyBGZXRjaFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGN1cnJlbnRTdG9yZSA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnSGlzdG9yeS5zdG9yZScpKXx8e307XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0Y3VycmVudFN0b3JlID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFbnN1cmVcblx0XHRcdFx0Y3VycmVudFN0b3JlLmlkVG9TdGF0ZSA9IGN1cnJlbnRTdG9yZS5pZFRvU3RhdGUgfHwge307XG5cdFx0XHRcdGN1cnJlbnRTdG9yZS51cmxUb0lkID0gY3VycmVudFN0b3JlLnVybFRvSWQgfHwge307XG5cdFx0XHRcdGN1cnJlbnRTdG9yZS5zdGF0ZVRvSWQgPSBjdXJyZW50U3RvcmUuc3RhdGVUb0lkIHx8IHt9O1xuXG5cdFx0XHRcdC8vIFN5bmNcblx0XHRcdFx0Zm9yICggaXRlbSBpbiBIaXN0b3J5LmlkVG9TdGF0ZSApIHtcblx0XHRcdFx0XHRpZiAoICFIaXN0b3J5LmlkVG9TdGF0ZS5oYXNPd25Qcm9wZXJ0eShpdGVtKSApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJyZW50U3RvcmUuaWRUb1N0YXRlW2l0ZW1dID0gSGlzdG9yeS5pZFRvU3RhdGVbaXRlbV07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggaXRlbSBpbiBIaXN0b3J5LnVybFRvSWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhSGlzdG9yeS51cmxUb0lkLmhhc093blByb3BlcnR5KGl0ZW0pICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1cnJlbnRTdG9yZS51cmxUb0lkW2l0ZW1dID0gSGlzdG9yeS51cmxUb0lkW2l0ZW1dO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGl0ZW0gaW4gSGlzdG9yeS5zdGF0ZVRvSWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhSGlzdG9yeS5zdGF0ZVRvSWQuaGFzT3duUHJvcGVydHkoaXRlbSkgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VycmVudFN0b3JlLnN0YXRlVG9JZFtpdGVtXSA9IEhpc3Rvcnkuc3RhdGVUb0lkW2l0ZW1dO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlXG5cdFx0XHRcdEhpc3Rvcnkuc3RvcmUgPSBjdXJyZW50U3RvcmU7XG5cdFx0XHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUoKTtcblxuXHRcdFx0XHQvLyBJbiBTYWZhcmksIGdvaW5nIGludG8gUHJpdmF0ZSBCcm93c2luZyBtb2RlIGNhdXNlcyB0aGVcblx0XHRcdFx0Ly8gU2Vzc2lvbiBTdG9yYWdlIG9iamVjdCB0byBzdGlsbCBleGlzdCBidXQgaWYgeW91IHRyeSBhbmQgdXNlXG5cdFx0XHRcdC8vIG9yIHNldCBhbnkgcHJvcGVydHkvZnVuY3Rpb24gb2YgaXQgaXQgdGhyb3dzIHRoZSBleGNlcHRpb25cblx0XHRcdFx0Ly8gXCJRVU9UQV9FWENFRURFRF9FUlI6IERPTSBFeGNlcHRpb24gMjI6IEFuIGF0dGVtcHQgd2FzIG1hZGUgdG9cblx0XHRcdFx0Ly8gYWRkIHNvbWV0aGluZyB0byBzdG9yYWdlIHRoYXQgZXhjZWVkZWQgdGhlIHF1b3RhLlwiIGluZmluaXRlbHlcblx0XHRcdFx0Ly8gZXZlcnkgc2Vjb25kLlxuXHRcdFx0XHRjdXJyZW50U3RvcmVTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShjdXJyZW50U3RvcmUpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFN0b3JlXG5cdFx0XHRcdFx0c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnSGlzdG9yeS5zdG9yZScsIGN1cnJlbnRTdG9yZVN0cmluZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRpZiAoZS5jb2RlID09PSBET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSKSB7XG5cdFx0XHRcdFx0XHRpZiAoc2Vzc2lvblN0b3JhZ2UubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdvcmthcm91bmQgZm9yIGEgYnVnIHNlZW4gb24gaVBhZHMuIFNvbWV0aW1lcyB0aGUgcXVvdGEgZXhjZWVkZWQgZXJyb3IgY29tZXMgdXAgYW5kIHNpbXBseVxuXHRcdFx0XHRcdFx0XHQvLyByZW1vdmluZy9yZXNldHRpbmcgdGhlIHN0b3JhZ2UgY2FuIHdvcmsuXG5cdFx0XHRcdFx0XHRcdHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ0hpc3Rvcnkuc3RvcmUnKTtcblx0XHRcdFx0XHRcdFx0c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnSGlzdG9yeS5zdG9yZScsIGN1cnJlbnRTdG9yZVN0cmluZyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIHdlJ3JlIHByb2JhYmx5IHByaXZhdGUgYnJvd3NpbmcgaW4gU2FmYXJpLCBzbyB3ZSdsbCBpZ25vcmUgdGhlIGV4Y2VwdGlvbi5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIEZvciBJbnRlcm5ldCBFeHBsb3JlclxuXHRcdFx0SGlzdG9yeS5pbnRlcnZhbExpc3QucHVzaChzZXRJbnRlcnZhbChIaXN0b3J5Lm9uVW5sb2FkLEhpc3Rvcnkub3B0aW9ucy5zdG9yZUludGVydmFsKSk7XG5cblx0XHRcdC8vIEZvciBPdGhlciBCcm93c2Vyc1xuXHRcdFx0SGlzdG9yeS5BZGFwdGVyLmJpbmQod2luZG93LCdiZWZvcmV1bmxvYWQnLEhpc3Rvcnkub25VbmxvYWQpO1xuXHRcdFx0SGlzdG9yeS5BZGFwdGVyLmJpbmQod2luZG93LCd1bmxvYWQnLEhpc3Rvcnkub25VbmxvYWQpO1xuXG5cdFx0XHQvLyBCb3RoIGFyZSBlbmFibGVkIGZvciBjb25zaXN0ZW5jeVxuXHRcdH1cblxuXHRcdC8vIE5vbi1OYXRpdmUgcHVzaFN0YXRlIEltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCAhSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGUgKSB7XG5cdFx0XHQvLyBCZSBhd2FyZSwgdGhlIGZvbGxvd2luZyBpcyBvbmx5IGZvciBuYXRpdmUgcHVzaFN0YXRlIGltcGxlbWVudGF0aW9uc1xuXHRcdFx0Ly8gSWYgeW91IGFyZSB3YW50aW5nIHRvIGluY2x1ZGUgc29tZXRoaW5nIGZvciBhbGwgYnJvd3NlcnNcblx0XHRcdC8vIFRoZW4gaW5jbHVkZSBpdCBhYm92ZSB0aGlzIGlmIGJsb2NrXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0dXAgU2FmYXJpIEZpeFxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIEhpc3RvcnkuYnVncy5zYWZhcmlQb2xsICkge1xuXHRcdFx0XHRIaXN0b3J5LmludGVydmFsTGlzdC5wdXNoKHNldEludGVydmFsKEhpc3Rvcnkuc2FmYXJpU3RhdGVQb2xsLCBIaXN0b3J5Lm9wdGlvbnMuc2FmYXJpUG9sbEludGVydmFsKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRW5zdXJlIENyb3NzIEJyb3dzZXIgQ29tcGF0aWJpbGl0eVxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIG5hdmlnYXRvci52ZW5kb3IgPT09ICdBcHBsZSBDb21wdXRlciwgSW5jLicgfHwgKG5hdmlnYXRvci5hcHBDb2RlTmFtZXx8JycpID09PSAnTW96aWxsYScgKSB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBGaXggU2FmYXJpIEhhc2hDaGFuZ2UgSXNzdWVcblx0XHRcdFx0ICovXG5cblx0XHRcdFx0Ly8gU2V0dXAgQWxpYXNcblx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLmJpbmQod2luZG93LCdoYXNoY2hhbmdlJyxmdW5jdGlvbigpe1xuXHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywncG9wc3RhdGUnKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gSW5pdGlhbGlzZSBBbGlhc1xuXHRcdFx0XHRpZiAoIEhpc3RvcnkuZ2V0SGFzaCgpICkge1xuXHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci5vbkRvbUxvYWQoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnaGFzaGNoYW5nZScpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IC8vICFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZVxuXG5cblx0fTsgLy8gSGlzdG9yeS5pbml0Q29yZVxuXG5cdC8vIFRyeSB0byBJbml0aWFsaXNlIEhpc3Rvcnlcblx0aWYgKCFIaXN0b3J5Lm9wdGlvbnMgfHwgIUhpc3Rvcnkub3B0aW9ucy5kZWxheUluaXQpIHtcblx0XHRIaXN0b3J5LmluaXQoKTtcblx0fVxuXG59KSh3aW5kb3cpO1xuIl0sImZpbGUiOiJqcXVlcnkuaGlzdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9

/*!
*** prettyPre ***/

(function ($) {

    $.fn.prettyPre = function (method) {

        var defaults = {
            ignoreExpression: /\s/ // what should be ignored?
        };

        var methods = {
            init: function (options) {
                this.each(function () {
                    var context = $.extend({}, defaults, options);
                    var $obj = $(this);
                    var usingInnerText = true;
                    var text = $obj.get(0).innerText;

                    // some browsers support innerText...some don't...some ONLY work with innerText.
                    if (typeof text == "undefined") {
                        text = $obj.html();
                        usingInnerText = false;
                    }

                    // use the first line as a baseline for how many unwanted leading whitespace characters are present
                    var superfluousSpaceCount = 0;
                    var currentChar = text.substring(0, 1);

                    while (context.ignoreExpression.test(currentChar)) {
                        currentChar = text.substring(++superfluousSpaceCount, superfluousSpaceCount + 1);
                    }

                    // split
                    var parts = text.split("\n");
                    var reformattedText = "";

                    // reconstruct
                    var length = parts.length;
                    for (var i = 0; i < length; i++) {
                        // cleanup, and don't append a trailing newline if we are on the last line
                        reformattedText += parts[i].substring(superfluousSpaceCount) + (i == length - 1 ? "" : "\n");
                    }

                    // modify original
                    if (usingInnerText) {
                        $obj.get(0).innerText = reformattedText;
                    }
                    else {
                        // This does not appear to execute code in any browser but the onus is on the developer to not 
                        // put raw input from a user anywhere on a page, even if it doesn't execute!
                        $obj.html(reformattedText);
                    }
                });
            }
        }

        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        }
        else if (typeof method === "object" || !method) {
            return methods.init.apply(this, arguments);
        }
        else {
            $.error("Method " + method + " does not exist on jQuery.prettyPre.");
        }
    }
})(jQuery);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJwcmV0dHlwcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbioqKiBwcmV0dHlQcmUgKioqL1xyXG5cclxuKGZ1bmN0aW9uICgkKSB7XHJcblxyXG4gICAgJC5mbi5wcmV0dHlQcmUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XHJcblxyXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcclxuICAgICAgICAgICAgaWdub3JlRXhwcmVzc2lvbjogL1xccy8gLy8gd2hhdCBzaG91bGQgYmUgaWdub3JlZD9cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgbWV0aG9kcyA9IHtcclxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkb2JqID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXNpbmdJbm5lclRleHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gJG9iai5nZXQoMCkuaW5uZXJUZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzb21lIGJyb3dzZXJzIHN1cHBvcnQgaW5uZXJUZXh0Li4uc29tZSBkb24ndC4uLnNvbWUgT05MWSB3b3JrIHdpdGggaW5uZXJUZXh0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSAkb2JqLmh0bWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNpbmdJbm5lclRleHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgZmlyc3QgbGluZSBhcyBhIGJhc2VsaW5lIGZvciBob3cgbWFueSB1bndhbnRlZCBsZWFkaW5nIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBhcmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdXBlcmZsdW91c1NwYWNlQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2hhciA9IHRleHQuc3Vic3RyaW5nKDAsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29udGV4dC5pZ25vcmVFeHByZXNzaW9uLnRlc3QoY3VycmVudENoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gdGV4dC5zdWJzdHJpbmcoKytzdXBlcmZsdW91c1NwYWNlQ291bnQsIHN1cGVyZmx1b3VzU3BhY2VDb3VudCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWZvcm1hdHRlZFRleHQgPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZWNvbnN0cnVjdFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJ0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGVhbnVwLCBhbmQgZG9uJ3QgYXBwZW5kIGEgdHJhaWxpbmcgbmV3bGluZSBpZiB3ZSBhcmUgb24gdGhlIGxhc3QgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZvcm1hdHRlZFRleHQgKz0gcGFydHNbaV0uc3Vic3RyaW5nKHN1cGVyZmx1b3VzU3BhY2VDb3VudCkgKyAoaSA9PSBsZW5ndGggLSAxID8gXCJcIiA6IFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW9kaWZ5IG9yaWdpbmFsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzaW5nSW5uZXJUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRvYmouZ2V0KDApLmlubmVyVGV4dCA9IHJlZm9ybWF0dGVkVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgYXBwZWFyIHRvIGV4ZWN1dGUgY29kZSBpbiBhbnkgYnJvd3NlciBidXQgdGhlIG9udXMgaXMgb24gdGhlIGRldmVsb3BlciB0byBub3QgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1dCByYXcgaW5wdXQgZnJvbSBhIHVzZXIgYW55d2hlcmUgb24gYSBwYWdlLCBldmVuIGlmIGl0IGRvZXNuJ3QgZXhlY3V0ZSFcclxuICAgICAgICAgICAgICAgICAgICAgICAgJG9iai5odG1sKHJlZm9ybWF0dGVkVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtZXRob2RzW21ldGhvZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1ldGhvZCA9PT0gXCJvYmplY3RcIiB8fCAhbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICQuZXJyb3IoXCJNZXRob2QgXCIgKyBtZXRob2QgKyBcIiBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkucHJldHR5UHJlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pKGpRdWVyeSk7Il0sImZpbGUiOiJwcmV0dHlwcmUuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
