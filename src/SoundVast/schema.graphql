# source: http://localhost:8080/graphql
# timestamp: Sun Oct 29 2017 16:55:30 GMT+0100 (W. Europe Standard Time)

schema {
  query: AppQuery
  mutation: AppMutation
}

type AppMutation {
  saveSong(song: SongInput!): Song
  saveLiveStream(liveStream: LiveStreamInput!): LiveStream
  rateAudio(audioRating: AudioRatingInput!): Rating
}

type AppQuery {
  song(id: String): Song
  songs(
    # Only look at connected edges with cursors greater than the value of `after`.
    after: String

    # Specifies the number of edges to return starting from `after` or the first entry if `after` is not specified.
    first: Int
  ): SongConnection
  liveStreams(
    # Only look at connected edges with cursors greater than the value of `after`.
    after: String

    # Specifies the number of edges to return starting from `after` or the first entry if `after` is not specified.
    first: Int
  ): LiveStreamConnection
  genres: [Genre]
}

interface Audio {
  id: ID
  audioId: Int!
  name: String!

  # The poster image for the audio
  coverImageUrl: String!

  # The user who uploaded the audio
  user: User

  # The genre the audio belongs to
  genre: Genre

  # The ratings that have been applied by users to this audio
  ratings: [Rating]
}

input AudioRatingInput {
  audioId: Int!
  liked: Boolean!
}

# The `Date` scalar type represents a timestamp provided in UTC. `Date` expects
# timestamps to be formatted in accordance with the
# [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard.
scalar Date

scalar Decimal

type Genre {
  id: ID
  name: String!

  # The type of category the genre belongs to, e.g. Music, Radio etc
  type: String!
}

type LiveStream implements Node, Audio {
  # The Id of the LiveStream
  audioId: Int!

  # The Global Id of the LiveStream
  id: ID!
  name: String!

  # The poster image for the live stream
  coverImageUrl: String!
  liveStreamUrl: String!

  # The user who uploaded the live stream
  user: User

  # The genre the live stream belongs to
  genre: Genre

  # The ratings that have been applied by users to this live stream
  ratings: [Rating]
}

# A connection from an object to a list of objects of type `LiveStream`.
type LiveStreamConnection {
  # A count of the total number of objects in this connection, ignoring
  # pagination. This allows a client to fetch the first five objects by passing
  # "5" as the argument to `first`, then fetch the total count so it could display
  # "5 of 83", for example. In cases where we employ infinite scrolling or don't
  # have an exact count of entries, this field will return `null`.
  totalCount: Int

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination.
  edges: [LiveStreamEdge]

  # A list of all of the objects returned in the connection. This is a convenience
  # field provided for quickly exploring the API; rather than querying for "{
  # edges { node } }" when no edge data is needed, this field can be used instead.
  # Note that when clients like Relay need to fetch the "cursor" field on the edge
  # to enable efficient pagination, this shortcut cannot be used, and the full "{
  # edges { node } } " version should be used instead.
  items: [LiveStream]
}

# An edge in a connection from an object to another object of type `LiveStream`.
type LiveStreamEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: LiveStream
}

input LiveStreamInput {
  name: String!
  liveStreamUrl: String!
  coverImageUrl: String!
  genreId: Int
}

interface Node {
  # Global node Id
  id: ID
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

type Rating {
  id: ID

  # Whether the user has liked the audio or not
  liked: Boolean!

  # The user that rated the audio
  user: User

  # The audio that was rated by the user
  audio: Audio
}

type Song implements Node, Audio {
  # The Id of the Song
  audioId: Int!

  # The Global Id of the Song
  id: ID!
  name: String!

  # The poster image for the song
  coverImageUrl: String!
  artist: String

  # The user who uploaded the song
  user: User

  # The genre the song belongs to
  genre: Genre

  # The ratings that have been applied by users to this song
  ratings: [Rating]
}

# A connection from an object to a list of objects of type `Song`.
type SongConnection {
  # A count of the total number of objects in this connection, ignoring
  # pagination. This allows a client to fetch the first five objects by passing
  # "5" as the argument to `first`, then fetch the total count so it could display
  # "5 of 83", for example. In cases where we employ infinite scrolling or don't
  # have an exact count of entries, this field will return `null`.
  totalCount: Int

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination.
  edges: [SongEdge]

  # A list of all of the objects returned in the connection. This is a convenience
  # field provided for quickly exploring the API; rather than querying for "{
  # edges { node } }" when no edge data is needed, this field can be used instead.
  # Note that when clients like Relay need to fetch the "cursor" field on the edge
  # to enable efficient pagination, this shortcut cannot be used, and the full "{
  # edges { node } } " version should be used instead.
  items: [Song]
}

# An edge in a connection from an object to another object of type `Song`.
type SongEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Song
}

input SongInput {
  name: String!
  artist: String
  coverImageUrl: String!
  genreId: Int
}

type User {
  id: ID
  userName: String!
  email: String!
  emailConfirmed: Boolean!
}
